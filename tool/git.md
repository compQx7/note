# Gitとは
* 最新バージョンの把握、過去のバージョンの利用、複数人での利用を目的としている
* 分散型。一般的にそれぞれの端末にリモートリポジトリのクローンを置く。ローカルの作業が終わったらリモートに反映（プッシュ）する
* gitはファイル単位ではなく、変更箇所単位で管理しており、この単位をHunkという。
* hunk単位でステージに上げてコミットすることができる。いずれにしてもコミットの単位は厳密にしておくことがバージョン管理のポイント。
* gitでは、ファイルを削除して一定以上内容が類似したファイルを追加した場合、変更として扱われる。

* [SourceTree] GitのGUI。内蔵Gitを持つ
* origin/masterとorigin/HEADは、bitbacket上（リモート）のブランチ最新位置。
* origin/masterがリモートリポジトリ、masterがローカルリポジトリ。
* 変更をもとに戻すこともできる。破棄は変更を消し、削除はファイルを消す。
* 競合したファイルで右クリックすると、どちらかの変更を反映するか選べる。
* [ベアリポジトリ] githubやbitbacketなどは作業コピーファイルなどが存在せず、どのブランチもcheckoutされていないベアリポジトリ。ベアリポジトリではマージもできない。

* [HEAD] 現在作業対象となっているブランチの先頭コミットを指す。
* ステージングしたものがコミットされる。
* [folk,clone,プルリク] 管理者のリモートリポジトリから自分のリモートリポジトリとしてコピーすることをフォークと呼び、管理者や自分のリモートリポジトリからローカルにコピーすることをクローンと呼ぶ。またフォークしたリポジトリを編集し、そのリモートリポジトリを管理者のリポジトリへ反映してもらう依頼をプルリクと呼ぶ。
* 作業を開始する前や、プッシュする前には必ずプルするように。作業が完了したらコミット→プル→プッシュ
* [コンフリクト] 開発環境の違いなどで起こる全行コンフリクトに注意。コンフリクトが発生していないファイルはマージされる。

* マージには4種類の状態がある。リモートから取り込むものがなくローカルは最新の状態Already up-to-date、ローカルに編集したものがなくリモートから取り込むだけのFastForward、ローカルに編集内容があるが競合のない取り込みの場合AutoMerge、競合が発生したConflict。
* Gitの変更箇所単位（管理単位）はハンクという。
* ベアリポジトリは「作業コピー」ファイルが存在せず、どのブランチもチェックアウトされていない（できない）リポジトリ。

## gitはスナップショット
* ブロブにはファイル内容が含まれるが、ファイル名は含まれない。
* Gitのディレクトリ構造を表すツリーにファイル名情報が含まれる。ツリーにはパス情報やパスの先のオブジェクトのOIDを持つ。
* ブランチはコミットを指し、コミットはルートツリーと他のコミットを指し、ツリーは他のツリーとブロブを指し、ブロブは何も指さない。
* 内容が同じオブジェクトは複数のツリーから参照可能。
* 差分はルートツリーから比較して動的に生成される。

# ブランチ
* ブランチのメリット。同時に複数の作業状態を独立保持して作業できる。一旦現在の作業を保留して、横入りタスクを行える。過去のある地点の状態に戻したり、最新状態に戻ることも自由自在。
* ブランチはコミットを指す軽量なポインタ
* コミットオブジェクトには親コミットIDなどが記載されている
* [メリット] 同時に複数の作業状態を独立保持できる。横から入った作業に切り替えれる。過去のある状態に戻ったり自由自在。
* [ブランチのマージ] 作業が完了したら、派生元となったブランチへマージする。完了したブランチは削除する。分岐ブランチで行ったコミットも取り込まれる。
* [中央リポジトリのブランチ作成] プッシュする際に中央リポジトリのmasterから派生したブランチ名を指定すると、ブランチを作成できる。

# リモート
## fork
* 他のリモートリポジトリを自分のリモートリポジトリに複製する
* 自分のリモートリポジトリを元の他のリポジトリに反映して欲しい場合にプルリクする。

## clone
リモートリポジトリをローカルリポジトリに複製する
git clone [RemoteRepositpryAddress]

## push
新規のローカルブランチをリモートに反映
git push [RemoteName] [BranchName]
git push origin feature_test

リモートのブランチを削除
git push --delete [RemoteName] [BranchName]

## fetch
リモートリポジトリの情報を（自分のリモート追跡リポジトリに？）取得する
git fetch [RemoteName]

リモートで削除されたブランチをローカルでも削除反映
git fetch -p(--prune)

## merge
fetchで取り込んだリモートの情報からマージする
git merge [RemoteName]/[Branch]

## リモート運用について
* レビュー不要なら、ローカルで作業したブランチをプッシュするブランチにマージしてからそのままプッシュすればいいらしい
* レビュー必要なら作業したブランチをプッシュしてマージしてほしいブランチを指定してプルリク。みんなに承認されたら管理者がリモートリポジトリでマージプルリク。

## プルリク
* 2種類のフローがある。ひとつはOSSのようなリポジトリを個人アカウントのリモートリポジトリにフォークし、プッシュした内容を本体リポジトリにプルリクする。もうひとつは、共用リポジトリでブランチを切り、プッシュした内容を別のブランチにマージしてもらうプルリク。

## SSH
GitHubに接続する際にSSHを使うと、毎回パスワードを入力することなく、セキュリティの高い方法でリポジトリへのアクセスや操作を行うことができます。SSHキーは公開キーと秘密キーのペアで構成されており、GitHubに公開キーを登録しておくことで、対になる秘密キーを持っているユーザーだけがアクセスできるようになります。これにより、パスワードよりも安全にサービスを利用することが可能です。GitHubへのSSH接続設定は以下のステップで行われます:

1. SSHキーペアを生成する。
2. 公開キーをGitHubのアカウントに登録する。
3. SSH経由でGitHubのリポジトリをクローンする際に、SSH URLを使用する。
4. 以降のプッシュやプルなどの操作がSSH経由で行われる。

これにより、セキュリティが保たれた状態で快適にGitHubを利用できるようになります。


### HTTPSから途中でSSHに切り替えることも可能

1. 現在のリモートURLを確認します。
   ```
   git remote -v
   ```

2. リモートURLをSSHのURLに変更します。
   ```
   git remote set-url origin [SSH URL]
   ```
   ここで `[SSH URL]` はGitHubのリポジトリページで「Clone or download」ボタンをクリックし、SSHを選択して表示されるURLです。

3. これでリモートURLがSSHに変更されたので、以降のプッシュやプルの操作をSSH経由で行うことができます。

リモートのURLを変更した後は、SSHキーが正しく設定されており、GitHubに登録されていることを確認してください。それでないと、認証エラーが発生してリモートリポジトリにアクセスできなくなります。


### 端末ごとに接続URLは異なる
iPhoneとWindows PCのそれぞれに異なるGitクライアントを使用している場合、それぞれのデバイスで異なる接続方法（HTTPSまたはSSH）を設定してリポジトリをクローンすることができます。リポジトリのクローン、プッシュ、プルなどのGit操作は、使用しているクライアントやデバイスによらず、リポジトリの設定に基づいて行われます。

ただし、異なるデバイス間でコードを同期する場合は、各デバイスで適切な認証情報（パスワードやSSHキー）が設定されている必要があります。また、リポジトリに変更をプッシュする前に、他のデバイスで行われた変更をプルしておくことで、コンフリクトを避けることが重要です。

`git remote` コマンドで確認した場合、それぞれの端末に設定されたリモートリポジトリのURLは異なることになります。これは、リモートのURLはローカルのGit設定に保存されており、端末ごとに設定が可能だからです。

例えば、Windows PCで `git remote -v` を実行するとSSHのURLが表示され、iPhoneで同じコマンドを実行するとHTTPSのURLが表示されるという状況になります。各デバイスはその設定に従ってリモートリポジトリへアクセスし、プッシュやプルを行います。

したがって、一方のデバイスでリモートのURLを変更しても、他のデバイスには影響を与えません。各デバイスは独立してリモートリポジトリとの接続方法を管理していると考えて良いでしょう。

### Gitの設定情報
Gitの設定情報は複数の場所に保存されていますが、リモートリポジトリのURLに関する情報は特に以下の場所に保存されています:

1. **ローカルレベルの設定**: これは特定のリポジトリ内にあり、`.git/config` ファイルに保存されています。このファイルには、そのリポジトリ固有の設定、例えばリモートリポジトリのURLやブランチの設定が含まれます。

2. **グローバルレベルの設定**: ユーザーのホームディレクトリにある `.gitconfig` または `~/.config/git/config` ファイルに保存されています。ここにはユーザー名、メールアドレスといった全リポジトリで共通のユーザー情報が含まれます。

3. **システムレベルの設定**: 全てのユーザーとリポジトリに適用される設定が保存されており、通常は Git のインストールディレクトリ内の `etc/gitconfig` ファイルにあります。

ローカルレベルの設定がリモートリポジトリのURLの設定に直接関連していて、`git remote set-url` コマンドを使うと、このローカル設定ファイルが更新されます。デバイスごとに異なるリモートURLを設定したい場合は、それぞれのデバイスでローカル設定を変更することになります。


# .gitフォルダ
`.git` フォルダにはそのリポジトリに関する全てのGit情報が含まれており、コミット履歴やブランチ情報などの多くの部分はクローン元のリポジトリから取得したもので共通です。しかし、特定の設定や作業状況に関する情報はローカル環境に依存するため、端末ごとに異なることがあります。

- **コミット履歴（`objects` フォルダ内など）**: これはクローンされた時点でのリモートリポジトリの状態を反映しており、特に新たな変更がなければどのクローンでも同じです。
- **リモートリポジトリのURL（`.git/config` ファイル内）**: これは各端末で設定されるため、異なるプロトコル（HTTPSやSSH）を使用している場合は異なります。
- **作業ディレクトリの状態（ステージングエリア、ワーキングツリー）**: 各開発者が作業している内容は端末ごとに異なるため、これも端末によって違います。


# tag
* 安定バージョンの復元ポイントなどはタグで目印を付ける。


# コマンド別
## init
## log

```sh
# 特定ファイルの変更履歴を表示
git log -- `<Path>`

# 特定のコミットの変更を確認
git log [CommitId] -p

# ブランチを指定
git log [Branch|--all]

# 表示するログの数を指定
git log -n `<count>`

# 時期を指定
git log --[since|until]:1years.2months.3days

# 視覚的に表示
git log --graph

# フォーマット指定
git log --pretty=[oneline|format:<String>]

git log --stat
git log -S `<FunctionName>`

git help log -> commit limiting
```

## status
* HEADと比較して、インデックス状況を表示？

## diff

```sh
# コミット間の差分表示。リモートとも比較できる。
git diff [変更前]..[変更後]
# HEAD（リポジトリ）とワークツリーとの差分確認
git diff
# HEAD（リポジトリ）とステージとの差分確認
git diff -staged
# 変更ファイル確認
git status
```

## add
* 引数に指定したファイルパスでインデックスを更新する
git add .

## commit
* インデックスにあるものをリポジトリに記録する

## branch

```sh
# リモートリポジトリも含めたブランチ一覧
git branch -a
# どのリモートブランチを追跡しているか、追跡ブランチとどれだけ離れているか
git branch -vv
```

## prune (fetch --prune)


## merge
* マージコミットには親となるコミットオブジェクトが２つ
* --abort コンフリクトが多いなどでマージを中止
* [merge] マージした時の反応は４種類。特にマージするものはなかった。取り込んで終わりのfast forward（リモートリポジトリ）競合箇所がなく完了のauto merge。競合発生。
* [merge] 反映を受け取る側へチェックアウトしてから、反映を送る側を指定してマージ。

git merge [Branch]
git merge [RemoteName]/[Branch]

## stash

```sh
# ワークツリーを一時退避する
git stash 
# uオプションをつけることで、追跡対象ではない新規のファイルも退避対象にできる
git stash -u 
# 保存したリストを見る
git stash list
# スタッシュを復活
git stash apply stash@{n}
# スタッシュを削除
git stash drop stash@{n}
# スタッシュを復活、削除
git stash pop stash@{n}
```

## reset
* 歴史を書き換えるので注意が必要。リモートにプッシュ前のコミットに対してのみ行うのが良い
* 引数に指定したファイルパスでインデックスを更新する
git reset [commit] [path]
git reset [path]
* ブランチのみを指定すると、ブランチの先頭（HEAD）を指定コミットの状態に戻す。モードの指定も可能。--soft はHEADの移動のみ（ワークツリー（作業内容）、インデックスを保持したまま戻る） (--mixed) インデックスを更新（ワークツリーは保持したまま） --hard はワークツリーもインデックスも更新
git reset [commit]
* HEAD は最新状態へ。HEAD^ は直前コミットへ。HEAD=n はn個前のコミットへ。[過去のコミットID] で指定もできる。HEADのエイリアス@。
* ex: git reset --soft HEAD~2 で作業内容を保持したまま２つコミットを消す（戻す）

## reflog
* HEADの移動履歴一覧を表示
* その後に git reset --hard HEAD@{n} でresetを取り消せる。

## revert
* コミットを打ち消す（逆のコミットを行う）。プッシュ済のコミットを打ち消したい時に便利
git revert [commit_id]

## checkout
* ブランチ名を指定すれば、ブランチを切り替える。ワークツリー、インデックスを保持したまま
* パスを指定すれば、指定したコミット（もしくはインデックス）の状態を作業ツリーに展開する。

## switch
* ブランチを切り替える。

## rebase
* 2つのブランチを一直線にする。（コピーするためのコミットIDは変わる）
* 複数のコミットをひとつのコミットにまとめる。
自分のコミットだけが枝分かれしている時に使うようにする。

## restore
* ワークツリーの変更を取り消す（git checkout . と似ている？）
git restore [FileName]
* ステージに挙げた変更をワークツリーに戻す
git restore -staged [FileName]

## cherry-pick
* 別のブランチから必要なコミットだけ取り込める
git cherry-pick [commit_id](..[commit_id])
* コミットはせずに取り込みたい（ワークツリーのみ変更
git cherry-pick -n [commit_id]

## grep
* gitに特化したgrep。リポジトリ内のみを検索、過去時点のファイル状態を検索できる。
git grep [keyword]
git grep --untracked [keyword] .gitignore記載のファイルも含めて検索
git grep [keyword] [commit/branch(ex:HEAD^)]
-i ファイル名を出力
git config --global grep.lineNumber true 行番号表示

## blame
* 各行にコミットした人の名前と日時を表示
git blame [filename]

## tag

## others
* [commit] コミット単位でしか戻したり消せないため、一つの作業単位で行うのが基本。
* [push] リモートに変更を反映する。
* [pull] リモートから変更情報を取得してマージ。
* [fetch,merge] ローカルリポジトリは、最後に取得したリモートの状態を保持している。リモートリポジトリは他の人が編集し更新されることがあり、その情報を取得するのがフェッチ。ローカルの状態を取得した最新の状態に合わせるのがマージ。プルはフェッチとマージ。


# 目的別

## 過去の状態に戻す
* 直前コミットに追加・コミットメッセージ修正
git commit --amend
* ステージング解除
git restore --staged `<File>`
<!-- git reset HEAD `<File>` -->
* checkout, revert, resetなど。
* 編集作業を破棄して最新コミットに戻す
git restore `<File>`
<!-- git checkout HEAD -- [もとに戻すファイル名] -->
* 過去のコミットの編集内容を打ち消すrevert。例えば１行消したコミットを打ち消すのであれば、１行追加したコミットを行う。
git revert [打ち消すコミット]
* あるブランチの過去のコミットに戻って、また先頭に戻る
git checkout [CommitId] ※detached HEAD
git checkout [BranchName] もしくは git switch -
* 過去のコミットにHEADを移すチェックアウト。
git checkout -b [作成するブランチ] [過去のコミットID]

## ワークツリー作業を戻す
* 編集内容（ワークツリー）を削除。ただし新しく追加したファイルは消えないので手作業で削除する必要がある。（指定したディレクトリ以下の変更をもとに戻す）git checkout .

## インデックスを削除
* インデックスの全てのファイルを取り消す
git reset (HEAD (.))
* 指定したファイルをインデックスから削除
git reset [path]
git reset HEAD [path]

## 差分確認
* HEADから見たインデックスの差分
git diff --cached (HEAD)

## git管理を外す
git rm --cache [FileName]

## ファイル名変更
git mv [FromPath] [ToPath]
コマンドを使用せずに名前変更した場合の履歴は、ファイルが編集されていなければ「rename」扱いとなり、ファイルが編集されていると「fromファイルの削除とtoファイルの追加」という扱いになる。
コマンドを利用すれば、ファイル編集していても「rename」かつ差分が取れる。そのため、基本的にコマンドを利用して名前変更の履歴とするようにしたい。

## detached_HEAD状態

## 複数のブランチで並行して作業したい
.gitフォルダがある階層とは別のフォルダ（OtherDirectory）を用意して
> git worktree add <OtherDirectory> <BranchName>

## コミットをまとめる
### rebaseを使う
> git rebase -i [CommitId]
- CommitIdは、指定したコミットより先（新しい）コミットを修正対象とする意。
- pickとなっているコミットは保持され、squashと指定したコミットは統合される。

## コミットメッセージを修正する
### 直前のコミットメッセージを修正
> git commit --amend -m "[NewMessage]"

### n個前のコミットメッセージを修正
1. vimで修正
   - pickをeditに変更
   - 修正するコミットがチェックアウトされた状態になる
> git rebase -i [Commit]
2. 変更の保存
> git commit --amend -m "[NewMessage]"
3. 現代のコミットに戻る
> git rebase --continue

# .gitconfig
## Gitを始める
git config --global user.name [Name]
git config --global user.mail [email]
git config --global color.ui auto

git config --global --edit .gitconfigファイルを編集
* エイリアス設定
[alias]
    s = status

git remote add [RemoteName(origin)] [URL]

# .git/config
* リポジトリ単位の設定ファイル
git config user.name ''

# コミットツリー
git log --graph --oneline --decorate=full

* developブランチで開発してmasterに取り込む
* 編集作業を取り消したい、やり直したい
* developブランチで機能追加の開発してたけど機能いらなくなった
* コミットしたけどさっきのコミットを少し修正したい（これができれば、個人が別デバイスで作業できる。）
* developで編集中に急にメインの修正をしないといけなくなった（条件：編集中作業はコミットしない。masterブランチで直接修正しない）
* まだコミットするほどじゃないけど一時セーブしたい（ここに戻れるようにしたい）
* ほかブランチのコミットと競合した


# memo

## Gitの仕組み
基本的に差分ではなく、すべてのファイルの状態のスナップショットを撮り、スナップショットへの参照を格納する。効率化のため変更がないファイルは再格納せず、以前の同一ファイルへのリンクを格納する。

スナップショットとはファイル丸ごと。変更されたファイルは変更部分ではなく、ファイル丸ごと。

pushはあるリポジトリのデータを他のリポジトリに転送する操作。

Gitは基本的にデータを追加するだけなので、スナップショットをコミットした後は、データを消すことは困難。

## Gitのデータ領域
.gitがあるところが作業ディレクトリ。（worktreeというのもある）

## Git管理で気をつけること
git rm
git mv
触る時はIDE閉じるのが無難

## 他
修正済はファイルに変更を加えたが、データベースにまだコミットされていない状態。
ステージ済は次のスナップショットのコミットに加えるために、修正したファイルに印を付けた状態。
コミット済はデータベースに安全に格納されている状態。

ワーキングディレクトリはプロジェクトのひとつのバージョンの単一のチェックアウト。Gitディレクトリの圧縮されたデータベースから引き出されて、利用、修正するためにディスクに配置される。

ステージングエリアは普通はGitディレクトリに含まれる。次のコミットに何が含まれるかの情報を蓄えたひとつのファイル。ファイルのスナップショットをステージに追加。

作業コピー内には「追跡されているもの（tracked）」と「追跡されていないもの（untracked）」がある。追跡されているファイルとは直近のスナップショットに存在したファイル。「変更されていない（unmodified）」「変更されている（modified）」「ステージされている（staged）」の3つの状態がある。

Gitにコミットするとコミットオブジェクトを作成して格納する。このオブジェクトにはステージしたスナップショットへのポインタや作者、メッセージのメタデータ、親となるコミットへのポインタが含まれる。

コミットを行うとその時点のシステムの状態がGitディレクトリ（リポジトリ）に保存される。ファイルの内容はblobオブジェクトとして、blobオブジェクトとファイル名の関係、ディレクトリ構成はtreeオブジェクトとして、そのルートツリーとすべてのメタデータへのポインタはコミットオブジェクトとして保持される。

ブランチはコミットを指す軽量なポインタ。今どのブランチで作業しているかを指す特別なポインタがHEAD（ローカルブランチを示す）。

変更を保存しているのではなく、スナップショットを保存している。（.git/objects）

originは追跡しているリポジトリの直近に追跡した地点の状態を表す。pushでリモートに反映し、fetchでリモートから反映する。


# 運用上のポイント、注意
* push前にremote情報を取り込む
* pull（fetch後のmerge）前にコミットかスタッシュする
* コンフリクトは修正したファイルをステージングすることで解消できる。改めてpullとpushを行う。
* ブランチはひとつの作業（目的）を完了させたら派生元にマージする。
* 運用ルールを決めてコンフリクトの抑制などに努める。
* リモートのブランチをそのままローカルに持ってきたい場合はpullではなくcheckout（origin/BrancName）。pullするとローカルの現在ブランチにmergeしてしまう。
* 復元ポイントとしてバックアップしたいということであれば、新しくブランチを用意するのではなくタグを利用する。タグは新たなコミットを許さないため、それ以上派生させない。
* ブランチを切り替える時に作業途中のものがある場合は必ずコミットかスタッシュをしてから切り替える。
* チーム参画時や複雑なGit作業を行う際、.gitを含むフォルダごとコピーしてバックアップを取る。
* ファイル名の変更と同時に内容の編集もコミットすると、削除と追加が同時に行われたことになり、名前変更の履歴が残らない。
* Git flowではmasterとdevelopには直接コミットせず、他のブランチからマージして管理する。
* GitHubやBitbucketではベアリポジトリが中央リポジトリとして管理されている。自身でもベアリポジトリで中央リポジトリ（リモートリポジトリ）を作成することはできる。
* webサーバーでサービスをギット管理する場合は、サーバーにGitをインストールし、ノンベアリポジトリを用意してpushを受けて管理する。hookという機能を利用して最新を反映する。

## リポジトリの肥大化を防ぐ、整理する
Gitリポジトリが肥大化する問題に対処するために、いくつかの方法があります。これらの方法は、不要なデータを削除し、リポジトリのサイズを減らすのに役立ちます。

1. **.gitignoreファイルの使用**:
   - 不要なファイルやディレクトリ（例：ログファイル、ビルド生成物など）を`.gitignore`ファイルに追加して、これらがリポジトリに追跡されないようにします。

2. **git gc (Garbage Collection)**:
   - `git gc`コマンドは、Gitリポジトリの不要なファイルやオブジェクトを削除し、圧縮します。
   - これにより、リポジトリの効率が向上し、ディスクスペースが節約されます。

3. **大きなファイルの削除**:
   - 過去のコミットに含まれている大きなファイルがリポジトリのサイズを大きくしている場合、これらを削除することが効果的です。
   - `git filter-branch` コマンドや [BFG Repo-Cleaner](https://rtyley.github.io/bfg-repo-cleaner/) のようなツールを使用して、これらの大きなファイルを履歴から削除します。

4. **git reflogのクリア**:
   - `git reflog` は過去の操作（コミット、マージ、リベースなど）の記録を保持しています。
   - これらの古いエントリを削除することで、リポジトリのサイズを減らすことができます。

5. **git prune**:
   - `git prune` コマンドは、到達不可能なオブジェクトをリポジトリから削除します。
   - このコマンドは通常 `git gc` の一部として自動的に実行されますが、手動で実行することもできます。

これらの方法を適用する前に、リポジトリの重要なデータのバックアップを取ることをお勧めします。また、チームで作業している場合は、他のメンバーと調整を行うことが重要です。特に、履歴を変更するような操作は、共有されたリポジトリに対して行うと問題を引き起こす可能性があります。

# GitHub manual
- 新しいリポジトリを作成
githubで new repository

- ディレクトリごとgit管理を外す
rm -rf .git/

- ターミナルにてmkdirでプロジェクト用ディレクトリ作成
- ディレクトリ内で
git init
- ファイルインデックスに登録（すべて）
git add (.)
- ローカルリポジトリにコミット
git commit -m "message"
- リモートリポジトリにインデックス作成
git remote add origin [remote repository url.git]
- プッシュ
git push origin master


git brach [new_branch]
git branch -[dD] [delete_branch]
