# 基本
* [final] クラスに付いたら継承禁止、メソッドに付いたらオーバーライド禁止。基本型フィールドに付いたら値を変えられない。参照型フィールドに付いたら参照先を変えられない。
* [super] 親クラスのインスタンス部を表す。

## Java SE
Java Standard Editionの略。基本的なAPI。
その他SEと共に利用する、大規模開発用のJava EEや、組み込み用のJava MEがある。

## JVM
Java Vertual Machineの略。Javaの実行環境。Javaアプリケーションを動かすのに必要。
複数のOS間でJavaを実行する目的で存在する。
実際にはJREをインストールし、そこに含まれる。

## JRE
Java Runtime Environmentの略。Javaを実行するためのセット。
対応するJava SEに応じたバージョン番号が付与される。
今では単独で配布されず、JDKとセットで配布される。

## JDK
Java Development Kitの略。Javaを開発・実行するためのセット。
JREのほかに、コンパイラやデバッガを含む。
対応するJava SEに応じたバージョン番号が付与される。

## OpenJDK
さまざまな企業や個人によって開発されるOpenJDKをベースに、各社がバイナリを提供している。

# Javaのデプロイ
クラスパスは、コンパイルされたJavaクラスとライブラリなどのリソースをロードするためにアプリ実行時に使用される。

ビルドパスは、プロジェクトのビルドに必要な依存関係を見つけるためにコンパイル時に使用される。コンパイルに必要なすべてのJavaライブラリが含まれる。

# 型
* 型が参照型かどうかを意識するだけでjava理解の近道。
* [util.Date] 基準日から何ミリ秒経過したかを示すlong型フィールドをひとつ持っている。
* 抽象的な型に入ってるものを厳密な型に入れるダウンキャストの時は、変数 instanceof 型名、でチェックしてからキャストする。
* immutableなクラス（Stringなど）の値変更は新しいインスタンスを生成するため、ループ処理で行うとメモリを消費するし、効率も悪い。そのような場合はmutableなクラス（StringBuilderなど）で対応する。

# 例外
* 例外の対処は2通り。try,catchで捕捉して処理するか、throwsで呼び出し元に任せる。
* throwsは例外を投げる可能性を示唆する。throwは実際に例外を投げる。呼び出し元クラスでtry,catchで例外をキャッチする。
* ストリームやデータベース接続処理では、try-with-resourceでC#のusingのような書き方ができる。finallyで終了処理を書かずとも処理してくれる。
* 複数の例外が発生する可能性がある場合、補足後の処理が同じならマルチキャッチが使える。
* nullチェックにはoptionalを積極的に使う。optionalを返すメソッドは良い意味でnullチェックを強制できる。

# DB
* JPA、JDBC、DAO、EntityとRepository

# クラスファイル
* ソースコードをコンパイラが機械語化し、リンカがモジュールやライブラリなどを全部くっつけて（プログラム実行時にロードしてリンクする動的リンクもある）、ローダがメモリに読み込む。
* [コンパイラの仕事] 字句解析でトークンに分解し、構文解析で構文木を生成し、意味解析で構文木を元に言語仕様に沿っているかチェックして中間コードを生成する。その後コードサイズの縮小や処理速度の向上を目的とした最適化が行われ、目的のオブジェクトプログラムが生成される。

# インターフェイス
* 定義できるフィールドは初期化された定数のみ。public final staticになる。

# 文字コード
* Javaは標準でUnicode
* 開発環境と本番環境でOSが異なると文字化けを起こすこともしばしば。対策としては、デフォルトエンコーディングを使わないこと。FileReaderクラスは使わずにFileInputStreamとInputStreamReaderを使う、それ以外のメソッドやコンストラクタでは必ずエンコーディングやcharsetを指定する。

# コレクション、ジェネリクス
* 拡張for文で扱えるのはiterableインターフェイスを実装しているインスタンスもしくは、配列となる。
* ListやMap,Setはiteratorオブジェクトを持っている。iteratorを使えば、ループ中に要素を削除できる。
* < > で型を指定しなければObject型となる。
* 型にはプリミティブ型（非参照型）と参照型がある。コレクションが扱えるのは参照型のみ。ただしオートボクシングにより、プリミティブ型は参照型として扱えるような別の型が用意されている（int -> Integer)。コンパイラがそれぞれの変換を補助してくれる。

## 配列
* サイズの初期化やサイズ変更が必要。
* Comparatorインターフェイスを実装して（ラムダで？）、Compareメソッドをオーバーライドする。戻り値が0以上なら第一引数、第二引数の順にソート。
* ソート対象のクラス自身がComparableインターフェイスを実装することでも、ソート順を定義できる。ただし、こちらの方法はソート方式をひとつしか定義できない。
* 可変長引数では String[] argsなどのように書いた場合は、配列で渡す必要があるため、呼び出し側で必ずnewが必要になる。String... argsと書くことで配列で渡す必要がなくなる。コンパイル時にはnew方式に変換される。

## List
* ArrayListは内部に配列を保持しており、要素の追加、検索などのパフォーマンスは配列の特徴と同じ。主に全体的な繰り返し処理が多い場合に使う。
* LinkedListは前後の要素の情報を持つ。主に配列の途中に要素の追加や削除を行うことが多い場合に使う。
* CopyOnWriteArrayは、iteratorやfor eachを使ったループを行う際に、元のリストをコピーして実行する。主に複数スレッドが同時アクセスする可能性がある場合に使う。

## map
* キーと値の組み合わせで値を扱う。
* LinkedListは要素の順序を保持する必要がある場合に使う。
* TreeMapはキーの値をもとに2分探索木のアルゴリズムによって要素をソートする。主にキーの大小を意識した部分集合を扱う場合に使う。
* ConcurrentHasMapは主に複数スレッドから同時アクセスする場合に使う。
* その他の場合にHasMapを使う。

## set
* 内部でmapを持っており、mapになくてsetにしかない処理はほとんどない。

## queue

# StreamAPIとラムダ式
主に動的に処理を変えるために利用（？）。
あくまで匿名クラスの実装を簡略化したもの（それにより関数型のような記述を実現したもの）。
関数型インターフェイスを匿名クラスで実装して、インスタンスを生成する。

## ストリーム処理
* コレクションの操作を効率的に行える。C#のLINQ式のようなことができる。
* streamの作成（streamなど）、中間操作（map、filter、sortedなど）、終端操作（forEach、collectなど）の3つの操作から成る。中間操作は複数書ける。

## ラムダ式
* 実装すべきメソッドがひとつしかないインターフェイス（関数型インターフェイス）を引数に取るようなsortなどでは、ラムダ式を渡すことができる。
* メソッド参照。forEachでコレクションに対して用意されているメソッドを代入できる。list.forEach(System.out::println)

# マルチスレッド
* マルチスレッド特有の問題は、バグの再現性が低く発見しづらい。そのため、不要なスレッドは作らないのが基本。
* 問題として、データの上書き、デッドロック、例外、無限ループなどが起こる。
* スレッドセーフのために、複数のスレッドから読み書きを行っても、データが破損しない、処理エラーが発生しない、デッドロックが発生しないようにする。
* 例えば「値を取得して変更」する処理をアトミック（分割できない最小単位）に実装しない場合（２つに処理が分かれている場合）、上書きが起こる可能性がある。
* ステートレス（クラス変数、インスタンス変数を持たない）にする。
    * ロジックで処理した結果の情報量が複数ある場合、結果をまとめるオブジェクトを作って呼び出しもとに渡す
    * ロジックそのものが非同期処理になる場合、コールバック処理を実装するか「Future」パターンを使用する。
* synchronizedブロックで囲む範囲はシングルスレッドになるため、適切に設定する。

# Javaパッケージ
* 基本的にはフォルダとパッケージは同様の構成になる。
* Eclipseでは、ソースディレクトリ配下にフォルダがあれば、パッケージとして扱われる。

# bean
フィールドを読み書きするためのgetter setterがあり、引数のないコンストラクタがあり、シリアライズ可能であるクラスのこと。
フィールドはすべてシリアライズ可能である必要がある。プリミティブはシリアライズ可能であり、stringもシリアライズ可能。
