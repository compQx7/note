# クラスと名前空間
* オブジェクトはクラス、オブジェクトを分類するための境界線は名前空間（namespace）で定義する。
* [変数名?.プロパティ] null条件演算子。変数がnullなら例外を返さずに全体もnullになる。
* [usingディレクティブ] 指定された名前空間のクラスを、単にクラス名だけで使用可能にする。
* [エントリーポイント] static void Main(strong[] args)


# 仕組み
* C#のプログラムはILという言語で書かれたプログラムにコンパイルされ、さらにJITコンパイルという仕組みで機械語にコンパイルされる。
* 現在の最新版は.NETであり、.NetFrameworkや.NetCoreは過去のバージョンのもの。
* program.csファイル（visual studioでプロジェクトを作成すると自動で生成）内にエントリーポイントであるMainメソッドがある。
* static修飾子を付けたクラスは静的クラスと呼ばれ、インスタンス化が不要になる。
* [Application.Runメソッド] プログラム終了のためのコードが呼ばれない限り、処理を実行し続けるための仕組み。たとえばウィンドウが閉じたらメッセージループが終了する。
* [メッセージループ] GUI処理用のキュー。Windowsではアプリの実行はWindowsメッセージ（処理実行の単位）を順次処理していく。メッセージループでは、メッセージキューにたまる順番待ちのメッセージリストをループしながらチェックして１件ずつ処理する。
* [partial] １つのクラスを複数のファイルに分けて記述できる。
* [主な流れ] .NET実行エンジンによってアプリのエントリーポイントであるMainメソッドが呼ばれる。MainメソッドはFormオブジェクトを生成し、Application.Runメソッドを呼び出す（メッセージループの開始）。このオブジェクト生成の際にコンストラクタによりInitializeComponentメソッドが呼ばれる。これでフォーム画面が開かれる。フォームが閉じられるとFormオブジェクトのdisposeメソッドが呼ばれて終了処理が行われる。これでApplication.Runメソッドが終了し、Mainメソッドの処理が全て完了しアプリが終了する。
* Mainメソッドがエントリーポイントになるが、クラスなどを定義せずに直接書く最上位レベルのステートメント（Mainメソッドのように振る舞う）として書くことでエントリーポイントにすることもできる。
* コマンドライン引数には args 変数でアクセスできる。

## 詳細
* Gridはセルのように扱い、StackPanelはグループ化して設定する。
* [ボタンイベント]XAMLファイルで、 click= に続けてイベント名。コードビハインド（xaml.csファイル）で処理定義。
* [依存関係プロパティ] DependencyPropertyクラスで定義。


# ファイル構成
* [designer.cs] イベントとイベントハンドラーを結びつける処理が自動生成されるファイルで基本的に触らない。components変数は複数のコンポーネントをまとめて管理するための変数。disposeメソッドは終了処理を記述するメソッド。明示的に終了させるときはdisposeメソッド、暗黙的な終了処理はデストラクタに書く。InitializeComponentメソッドで実際の初期化処理を行う。
* [objフォルダ、binフォルダ] プログラムを開始するときに自動生成されるフォルダ、中身のファイルも自動生成。binフォルダに何か保存したいなら、そのファイルをプロジェクトに追加し、「出力ディレクトリにコピー」を使う
* [.dllファイルと.exeファイル] 実行可能ファイルは.dllファイルと.exeファイル。.exeはOSの差異を吸収する。これらの実行可能ファイルを生成することをビルドという。ビルドする際には実行可能ファイルを生成するための中間ファイルも生成される。この中間ファイルが保存されるのがobJフォルダ。.exeファイルは.dllファイルを実行するための仕掛けで、VisualStudioがない環境でも実行できる。
* [debugビルドとreleaseビルド] 既定では2つのビルド構成がある。debugビルドをしたらbinフォルダ内に
* [他のPCなどで実行するのに必要なもの] アプリケーション本体、アプリケーションの依存関係、.netのランタイム/ライブラリ。本体は.exeや.dll。依存関係は、設定ファイル、外部機能、DBや画像ファイル（.exeなどにも埋め込める）など。最後はアプリケーションを動作させるために必要なソフトウェア。VisualStudioでは必要なものをまとめて集めてくれる機能として「発行」がある。一般的なデプロイ。.pdbファイルには個人情報なども含まれるが、なくても動作するので削除して良い。
* [Properties/AssemblyInfo.cs] プログラムのバージョン情報に関する設定データを保持
* [Properties/Resources.resx] アプリで使用する文字列やグラフィックなどのデータを格納する。
* [app.config, exe.config] app.configファイルはアプリケーション構成ファイル。ビルドすると出力ディレクトリに[プログラム名].exe.configという名前で生成される。

# 言語基本
* クラスのフィールド名は小文字、メソッドの始まりは大文字
* [コメント] /* */や//
* [出力] Console. WriteLine()
* [型宣言と型の種類]
* [キャスト]  (型)変数
* [定数] const
* [値型と参照型] newするものは参照型でありヒープ領域に
* ガベージコレクションなどのメモリ管理。インスタンスへの参照をなくす必要がある。
* 型推論：var 変数名

## 配列、コレクション
* 型[] 配列変数名 = new 型[要素数]
* 多次元配列、型[,] 配列変数名 = new 型[要素数, 要素数]
* 配列変数.length
* foreach (型 変数名 in 配列変数名)
* ジャグ配列
* 配列は最初にサイズを指定して領域を用意するが、リストは長さを自由に変えられる。
* ハッシュテーブルを扱える Dictionary
* 重複なく管理できるHashSet

## 文字列
* environment.NewLineでOSの差異を吸収した改行
* $" "で補間機能付き文字列、@" "で逐語的文字列（エスケープシーケンスさせない）

## 数値
* 誤差の出ないdecimal 型

## 構造体
* 構造体とクラスの違いは、実行効率とメモリ効率。構造体は値型。
* 大きいオブジェクトは参照型が有利、小さなオブジェクトは値型が有利。
* 値型はnullにならないが、 null許容型にしてnullを代入できる。

## クラス
* セッター、ゲッターを記述する仕組みプロパティがある。フィールドに対するプロパティは先頭が大文字になる。フィールドを省略することもできる。
アクセサ修飾子 型名 プロパティ名 {set{}get{}}
アクセサ修飾子 型名 プロパティ名{set;get;}

* 単一継承
* [サブクラスのコンストラクタ] 先に必ずスーパークラスのコンストラクタが呼ばれる。
* すべてのクラスはobjectクラスを継承している
* [オーバーライド] 継承したクラスのメソッドと同名クラスを定義。スーパークラスには virtual修飾子を付け、サブクラスには override修飾子をつける。
* 匿名クラス。new [] {中身}
* 継承の場合、スーパークラスのコンストラクタが呼ばれてからサブクラスのコンストラクタが呼ばれる。スーパークラスのコンストラクタが引数を必要とするなら、サブクラスのコンストラクタで : base(引数) 。

### インターフェイス
*インターフェイス名は「 I」から始まる名前で命名する慣習

## 匿名関数
匿名関数はコンパイラがクラスメソッドやインスタンスメソッド、クラスなどを内部的に作って、それを参照するデリゲートを作っている

## 匿名関数（匿名メソッド、ラムダ式）の利点
ロジックを一箇所に集約できる（メソッドの内容を調べる時に行ったり来たりしなくて済む）
メソッドを参照したデリゲートのインスタンスを作る必要がない。
デリゲートの生成だけでなく、式ツリーの生成にも使える。

ラムダ式とデリゲートとFunc<T, TResult>、拡張メソッドと型推論を学べばLINQは理解できる。

## 式ツリーとは
コードを定義するデータ構造。
ひとつの文（ステートメント）をノードに分解して解釈する。
C#では非同期処理は式ツリーにできない。Taskオブジェクトを直接操作する必要がある。

## デリゲート
* C#のデリゲートは言語仕様の機能で、一般的なデリゲートとは少し異なる。実体はMulticastDelegateクラスの派生クラス。
* デリゲートのインスタンス化はメソッド内でのみ可能。
* 主にイベント（ユーザーアクション）やコールバック関数（「ある関数の引数」として渡される別の関数）を実現するための機能
* 他のクラスのメソッドを参照するオブジェクト（型）
* 処理を任せる側は実際にどのクラスが処理するのか、どんな処理をするのか、意識しなくて良い。GUIの処理とその際の実行結果を切り分けられる。
* +=で複数のメソッドを追加できる。
* 最近のC＃ではラムダ式で同じようなことができる（？）

オブジェクト指向の委譲（転送）、JavaScriptの委譲とは異なる。
コンポーネント間の結合度を最小限にしたソフトウェア設計を可能にするメカニズム
+=や-=でデリゲートの追加、削除が行えるため、ひとつのロガーでファイル出力とコンソール出力が行えたりもする。デリゲートを使うロガークラス自体に変更が必要ないのも利点。

## ジェネリック
* 同一の関数（クラス）で引数や戻り値の型が異なるものを共通化できる仕様。
* 戻り値の型 メソッド名<型引数>(引数型 引数)
* 型引数はメソッドにデータ型を渡すためのもの。
* ジェネリック型制約で型を限定することで、限定された型で使えるメソッドを利用可能。where 型引数名 : インターフェイス等
* メソッドだけでなく、クラスやインターフェイス、デリゲートもジェネリック化可能。

## LINQ
* クエリ構文とメソッド構文がある
* 標準の拡張メソッド
* 遅延評価。即時に評価されず必要になった時に評価される。クエリ変数がforeachなどによって評価されるまで遅延される。
* クエリ変数はクエリの結果ではなくクエリを格納する。
* 連続した値（シーケンス）を返すクエリでは、クエリ変数そのものは結果を保持せず、クエリのコマンドが保持される。即時に実行したい場合はToListなとを使う。
* 単一の値を返すクエリは即時実行される。

### LINQ Entity
Singleではなくfindでキャッシュから先に探す。
削除関数前にアタッチ関数を使うことで無駄なselectをなくせる
セーブチェンジスはトランザクショナル

### メソッド構文
* クエリ構文でできることはメソッド構文でできる。コンパイルされるとメソッド構文になる。

### クエリ構文
* select句かgroup by句で終わる。
* from x in xs から始まる。データ集合から要素を取り出す。Xの型は推論される。
* 複数のfrom句でfor eachの入れ子のようなことができる。複数のfrom句で別のソースを指定するとcross joinを実行できる。
* join句は基本的に内部結合。equalsのみサポートされる。joinとintoを使用した一般的なSQLにはないグループ結合もある。また、グループ結合とDefaultIfEmptyで左外部結合もできる。
* where句は真を返す要素をフィルタリングする。
* group句はキーでグループ化できる他に、範囲でグループ化したり、プール値（条件指定）でグループ化できる。
* let句はメソッド呼び出しの結果を格納できる場所を宣言、初期化する。
* select句はそれまでに抽出した値に関数を適用する。
* select句とgroup by句で使用できるinto句は別名にクエリを格納し、次のクエリに渡せる。

## 拡張メソッド
* 既存の型（インターフェイス）やクラスに対して、変更や継承をせずにメソッド（機能）を追加できる。
* 元クラスと名前空間が違う場合はusingによる指定が必要。元クラスに本来あるべき機能なら拡張メソッドではなく、元クラスを修正した方がいいと思う。
* staticなクラスの中に拡張メソッドを作る。
* 拡張メソッド自身もstaticにする。
* 引数の一つ目を「this 型 引数名」にする。
* その一つ目の引数が、拡張メソッドを使う値自身のことをさすことになる。二つ目以降の引数は拡張メソッドの引数となる。
* 拡張メソッド内では、そのクラスのprivate変数にはアクセスできない。

## null判定
変数を利用する際、変数名の後ろに?を付けることで、変数がnullだった場合にアクセスしない


# データベース
# プロジェクト
* 依存関係はどのプロジェクトがどのプロジェクトを参照するか（他のプロジェクトの機能を使えるようにするか）
* プロジェクトを分けることで依存関係が明確になる。

# ドメイン駆動
* WinFormはdomainとinfrastructureを参照する
* ビジネスロジックを書くDomainはどこも参照しない最上位
* 外部との接続部分を書くInfrastructureはdomainを参照
* Testはすべてのプロジェクトを参照



#フレームワーク

## ASP .NET
* controller クラスは必ず語尾が Controllerである必要がある。
* controllerクラスを継承する。
* controllerはひとつ以上のアクションメソッド（リクエストを処理）を持つ。
* ルーティングはStartup.csのConfigureメソッドで定義。

### Razor
テンプレートエンジン

### MVVM
* Viewのコントロールに連動してデータバインドさせる画面制御クラスをViewModelとする。画面制御のロジックを分離することで、インターフェイスのコードをテストコードで検証できる。

### コントローラー
* 必ずControllerクラスを継承。viewがない場合はControllerBaseクラスを継承。

### ルーティング

## Entity Framework
.Netの標準O/Rマッパー
テーブル同士の対応関係（m:nなど）のみ定義
DbContextはアプリケーションからデータベースへのゲートウェイ。
DbContextにはひとつ以上のDbSetが紐付く。テーブルに相当する。アプリケーションからLinqによるクエリを発行して、ランタイムにSQLに変換される。

* insert,update,deleteが実際に実行されるには、EntityStateの状態を変え（Add、Update、Remove）、SaveChangesAsyncを行う。

## UWPとは
* ユニバーサルWindowsプラットフォーム
* 区切りられたサンドボックス上にありセキュア
* デバイスを問わないアプリを開発できる
* セキュリティの仕組み上、クライアントからDBサーバーにアクセスさせる開発は困難。アプリを通じてアクセスすふ。
* 配布方法も限定されている

## XAML,WPFアプリ
* [xaml] CLRオブジェクトを生成するためのマークアップ言語。
* xamlもxaml.cs（コードビハインド）もViewクラスの一部。ビルド時に合成。見た目のロジックを分離。
* [StaticResource] リソースを定義しておくことで、1つの定義を複数のコントロールで共有できる。例えば複数のボタン色を一括で変更できる。
* [App.xaml] アプリケーション全体に関わることを記述。グローバル変数もここ。App.xaml内の記述で、リソースの定義をプロジェクト全体で共有できる。またコントロールごとのデフォルト設定もできる。他にもグループ設定や一部上書きなどもできる。
* [アプリケーション構成ファイル] .exe.configファイルをXMLで記述。エグゼファイルの設定用ファイル。VisualStudioを利用しているのであれば、生成先を指定できる。
* [Style] Styleの定義によりCSSのような定義ができる。またマウスがフォーカスされた時などのトリガーによるスタイル変更も定義できる。
* [Template] テンプレート機能により、ボタンの機能を持ちつつ外観を任意に変更できたりする。
* [データバインディング] スライダーの変動する値をテキストボックスの値に連携するなど。
* [コマンド] コピー機能のような意味論的なイベントをコマンドという。それに対してショートカットキーからコピーしたり、メニューからコピーを選択するのは、生の入力イベントとなる。生の入力イベントが意味論的なイベントであるコマンドに紐付き、イベント処理が実行される。
* モデルの持つ１つのデータを複数のビューから参照する仕組み（バインディング）と、データが変化したことを各ビューに通知する仕組み（コマンド）でビューとモデルの疎結合を保つ。

## Razor
インライン（コードナゲット）
@... @(...)

@のエスケープ
@@

コードブロック
@{...}

制御構文
@if (条件) {...}
@foreach (var 変数 in 集合) {...}

* Pagesの中にcontrollerとviewがあるイメージ。.cshtml.csはViewModel + Actionメソッド（OnGetなど）を定義。
* ActionメソッドをRazorPagesハンドラーと呼ぶ。
* @pageディレクティブは.cshtmlであることを示す。コントローラーを経由せずに要求を処理することを表す。

* razorの仕組みとasp-for、繰り返し構文
BindingPropertyはあくまで、クライアントから送られるデータを、どの変数（プロパティ）をターゲットにするか（バインド・紐付ける）を設定するだけだった。
Springとか他のフレームワークだと、リクエストメソッドの引数で、受け取るデータ（クライアント→サーバー）を全部指定したりするから、razorのBindinfPropertyはシンプルに書けるのが利点なのかも。
html（razor pages）側でid. value（asp-for）を明示して、初めてクライアント→サーバーの送信ができる。
カレンダーのように複数行まとめてpostしたい時は、forでインデックスをループして、
<input type="hidden" asp-for=@Model.SampleList[i] />
みたいにすると各行の値をまとめて送れる。


## 標準ライブラリ？
* subString: 指定位置の文字列抽出
* String.IndexOf: 指定文字が最初に見つかった位置を取得（第2引数で検索開始位置を指定可能、後ろから検索の場合はLastIndexOf）
* Enumerable.Range: 連番生成
* .Zip: 複数のコレクションをセットで処理（合体？）する（連番をくっつけたり）

* delegate、関数を代入できる変数
* デリゲート型定義をしなくても、引数にAction型、function型変数で定義できる。
* コールバック関数、何か処理が終わった後に呼び出したい処理

# C#非同期処理
await した処理は別スレッドで動かし、メインスレッドの制御は呼び出し元（awaitを使っている処理の呼び出し元）に戻す。別スレッドで動いてる処理が完了したらawaitした処理の後続処理に進む。この際、メインスレッドに処理が戻った時点でユーザーは操作が可能になる。
投げっぱなしにしたい場合は、非同期処理をawaitしなければ良い。

非同期処理を待機する箇所で「await」し、「await」を含んだ関数は「async」関数として宣言をする。これにより、awaitした箇所で処理は中断し、制御はasync関数の呼び出し側へと返され、非同期処理が完了した時点でasync関数の残りのコードが実行されるようになる。
