
# 基本
HTMLとJavasscriptをセットにしてコンポーネントとして定義する。
仮想DOMという仕組みで、実際のDOMと比較して差分のHTMLだけを更新する。
コンポーネントはクラスとしての表現方法と関数としての表現方法がある。（現在は主に関数コンポーネント）
コンポーネントは見た目と機能を持ったUI部品
1コンポーネント1ファイルにして分ける
子コンポーネントでexportすることで、親コンポーネントでimportできるようになる。
親から子に引数として渡す値がprops
コンポーネントを責務を明確にして分けることで、再利用しやすく、修正しやすく管理できる。

ツールチェインを使わない create react app という方法がある。Babel,Webpackなど
npx create-react-app

Reactコンポーネントが再描画されるきっかけは、state,propsが変更されたとき。

* 関数コンポーネントはその性質上、状態や副作用を持てない。その欠点を補う形でHooksがある。
* stateなどのデータは実際にはメモリ上で保持される。イベントなどによりReactのjavascriptが動き、stateの管理や再レンダリングを行う。
* データをメモリ上で管理するため、画面更新や画面遷移があるとデータは失われる。設定や認証情報は local strage を利用する手もある。

## マウント・アンマウント
コンポーネントがDOMに追加されることをマウント、削除されることをアンマウントという。

## props
props とは自分で調整できるコントローラの「ツマミ」のようなもの。関数における引数と同じ役割を果たしています。React コンポーネントは props というオブジェクトを唯一の引数として受け取っている。
親のstateを変更する必要があるなら、propsで子にイベントハンドラを渡す。

## state
コンポーネント内部で管理する状態（値）
フックによってstateが変更されると再レンダーされる。

コンポーネント単位に保持する状態変数。これがReactの仕組みにより更新された時、再レンダーが行われる。

## children
スプレッド構文は慎重に使ってください。この構文をあらゆるコンポーネントで使っているなら、何かが間違っています。多くの場合は、コンポーネントを分割して JSX として children を渡すべきというサインです。
children プロパティを有するコンポーネントには、親に任意の JSX で「埋めて」もらうための「穴」が開いている、と考えることができます。children は、パネルやグリッドのような視覚的に何かを囲む要素に使うことができます。

## 画面設計
最初に画面を設計し、どんなコンポーネントで構成するか、何（値、状態など）をどのコンポーネントで持つか考える。誰がハンドラーを定義して誰が実行するか。

## アプリケーション構造
各.tsx -> App.tsx -> index.tsx -> index.html

# hooks
## useEffect
実行タイミングの制御のためのフック。DOMレンダリング後に実行される。主に副作用（UI構築以外の処理）を実行する。
コールバック関数から返されるクリーンアップ関数はアンマウント時に実行される。

処理の実行タイミングをレンダリング後まで遅らせるhook。

## useContext
Reactコンポーネントのツリーに対して「グローバル」とみなすデータについて利用するように設計されている。コンポーネントの再利用を難しくするため慎重に使う必要がある。

## HTMLとの違い
* class -> className
* タグの属性に代入するときは { }で囲う。（Javascript形式）

# react 公式doc
## JSX
マークアップとロジックを分離（技術の分離）するのではなく、コンポーネントの単位で関心の分離を行う。
JSXは式である。コンパイルの後、JSの関数呼び出しに変換され、JSオブジェクトへと評価される。
JSXでJSの値は{}で渡す。JSオブジェクトを渡す場合はオブジェクトを{}でラップする。（{{}}となる）

DOMを値として考えて仮想DOMで操作する。レンダリング時にDOMとの差分を抽出する。

JSXの実体は、CreateElementによって生成されたReact要素。

## レンダーされた要素の更新
React要素はイミュータブル。一度作成すると子要素や属性は変更できない。特定のある時点のUI。

## コンポーネントとprops
propsはタグのクラスやIDみたいなもの。この値によってコンポーネントをカスタマイズできる。
概念的にはコンポーネントはJSの関数に似ている。propsという任意の入力を受け取り、画面上に表示すべきものを記述するReact要素を返す。

```js
// 関数コンポーネント
function Welcom(props) {
    return <h1>hello, {props.name}</h1>;
}
// クラスコンポーネント
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

コンポーネントは最初は大文字推奨
コンポーネントが使用される文脈ではなく、コンポーネント自身からの観点でpropsの名前を付ける。
UIの一部（ボタンなど）が複数回使われている場合や、そのUI自体が複雑な場合は別コンポーネントとして抽出する価値は大きい。

全ての React コンポーネントは、自己の props に対して純関数のように振る舞わねばなりません。自分自身のpropsは変更してはいけない。

## propsとstate
原則として、propsはコンポーネントのレンダリングを設定する際に使い、stateは時間経過で変化するようなデータ（状態）を追跡する際に使う。

## stateとライフサイクル
ライフサイクルメソッド
多くのコンポーネントを有するアプリケーションでは、コンポーネントが破棄された場合にそのコンポーネントが占有していたリソースを解放することが重要。componentDidMount、componentWillUnmountなどのライフサイクルメソッドを活用する。
renderメソッドは更新が発生するたびに呼ばれる。これによりReactは何を表示すべきかを知る。その後ReactはDOMをレンダー出力と一致するように更新する。
componentDidMountメソッドは出力がDOMにレンダーされた後に実行される処理。
constructor > render > （出力がDOMに挿入されると）componentDidMount

stateは直接変更せず、setStateを利用する。（直接更新できるのはコンストラクタ内のみ）
this.propsとthis.stateは非同期に更新される。そのためお互いの値に依存するべきではない。
stateはコンポーネント自身以外からはアクセスできない。ローカル、カプセル化されている。
コンポーネントは子コンポーネントにpropsとして自身のstateを渡すことはできる。つまりstateはそのコンポーネントよりも下にのみ影響する。任意の場所で追加で合流してくる水源のようなもの。

## コンポーネントを純粋に保つ
- コンポーネントは自分の仕事に集中する。レンダー前に存在していたオブジェクトや変数を書き換えない。
- 入力が同じなら出力も同じ。同じ入力に対しては、常に同じ JSX を返すようにする。
- レンダーはいつでも起こる可能性があるため、コンポーネントは相互の呼び出し順に依存してはいけない。
- コンポーネントがレンダーに使用する入力値を書き換えない。これには props、state、コンテクストが含まれる。画面を更新するためには既存のオブジェクトを書き換えるのではなく、代わりに state をセットする。
- コンポーネントのロジックはできるだけコンポーネントが返すJSXの中で表現する。何かを「変える」必要がある場合、通常はイベントハンドラで行う。最終手段として useEffect を使用する。
- 純関数を書くことには訓練が必要だが、それにより React パラダイムの威力が発揮される。

## コンポーネントにpropsを渡す
props を渡すには HTML で属性を書くのと同様のやり方で JSX 内に書く。
props を読み出すには、function Avatar({ person, size }) のような分割代入構文を使う。
size = 100 のようなデフォルト値を指定でき、これは props がない場合や undefined の場合に使われる。
<Avatar {...props} /> のような JSX スプレッド構文ですべての props を転送できるが、多様は禁物！
<Card><Avatar /></Card> のようなネストされた JSX を書くと Card コンポーネントの children プロパティになる。
props とはある時点での読み取り専用のスナップショットである。レンダー毎に新しいバージョンの props を受け取る。
props を書き換えることはできない。インタラクティブ性が必要な場合は state を設定する必要がある。

## 条件付きレンダー
React では、JavaScript を使用して分岐ロジックを制御する。
if 文を使用して、条件に応じて JSX 式を返すことができる。
JSX 内で中身を条件付きで変数に保存し、波括弧を使用して他の JSX 内に含めることができる。
JSX 内の {cond ? &lt;A /&gt; : &lt;B /&gt;} は、「cond であれば &lt;A /&gt; をレンダーし、そうでなければ &lt;B /&gt; をレンダーする」という意味である。
JSX 内の {cond && &lt;A /&gt;} は、「cond であれば &lt;A /&gt; をレンダーし、そうでなければ何もレンダーしない」という意味である。
これらのショートカットは一般的だが、プレーンな if が好きなら必ずしも使わなくて良い。

## リストのレンダー
アイテムのインデックスを key として使用したくなるかもしれません。実際、key を指定しなかった場合、React はデフォルトでインデックスを使用します。しかし、アイテムが挿入されたり削除されたり、配列を並び替えたりすると、レンダーするアイテムの順序も変わります。インデックスをキーとして利用すると、微妙かつややこしいバグの原因となります。
同様に、key={Math.random()} などとしてキーをその場で生成してはいけません。こうするとキーがレンダーごとに一切合致しなくなり、コンポーネントと DOM が毎回再作成されるようになります。これは遅くなるのみならず、リストアイテム内のユーザによる入力値も失われてしまいます。代わりに、データに紐づいた安定した ID を使用してください。
コンポーネントは key を props として受け取らないということに注意してください。React 自体がヒントとして使用するだけです。コンポーネントが ID を必要とする場合は、別の props として渡す必要があります：<Profile key={id} userId={id} />。
**keyのルール**
- キーは兄弟間で一意でなければなりません。
- キーは変更してはいけません

## UIをツリーとして理解する
React アプリは、多数のコンポーネントが互いにネストされることで形成されます。React をはじめとする多くの UI ライブラリは、UI をツリーとしてモデル化します。アプリをツリーとして捉えることにより、コンポーネント間の関係を理解するのに役立ちます。これを理解することで、これから学んでいくパフォーマンスや state 管理に関連した問題をデバッグするのに役立つでしょう。
ReactはコンポーネントからUIツリーを作成する。UIツリーはDOMへのレンダーに使用される。
- ツリー構造とは、何らかの物どうしの関係性を表現する際の一般的な方法である。UI をモデル化するために多用される。
- レンダーツリーは、1 回のレンダーにおける React コンポーネント間のネスト関係を表現するものである。
- 条件付きレンダーにより、毎回のレンダー間でレンダーツリーは変化する可能性がある。例えば props の値が変わることでコンポーネントは異なる子コンポーネントをレンダーする可能性がある。
- レンダーツリーの概念は、トップレベルとリーフコンポーネントを特定するのに役立つ。トップレベルのコンポーネントはそれらの下の全コンポーネントのレンダーパフォーマンスに影響を与え、リーフコンポーネントは頻繁に再レンダーされる。これらを把握することでレンダーパフォーマンスの理解とデバッグに役立つ。
- 依存関係ツリーは、React アプリ内のモジュール依存関係を表現する。
- 依存関係ツリーは、アプリを届けるために必要なコードをバンドルするビルドツールによって使用される。
- 依存関係ツリーは、ペイントまでの時間を遅らせるバンドルサイズの問題をデバッグしたり、どのコードをバンドル対象とするか最適化するきっかけとなることに役立つ。

## レンダー
- レンダーとはReactがコンポーネントを呼び出すこと。
- 更新されたコンポーネントが他のコンポーネントを返す場合、再帰的にReactが呼び出す。

1. レンダーのトリガー
    - 初回レンダー: rootコンポーネントを呼び出す。
    - state更新後レンダー: レンダーがトリガーされた関数コンポーネントを呼び出す。
1. コンポーネントのレンダー
    - 再レンダー時には、React は前回のレンダーからどの部分が変わったのか、あるいは変わらなかったのかを計算します。次のステップであるコミットフェーズまでこの情報は使われません。
1. DOMへのコミット
    - レンダー結果が前回と同じ場合は、ReactはDOMを触らない。以下のコードで再レンダーされるのはh1だけ。
```js
export default function Clock({ time }) {
  return (
    <>
      <h1>{time}</h1>
      <input />
    </>
  );
}
```

## stateはスナップショット
コンポーネントのメモリとしての state は、関数が終了したら消えてしまう通常の変数とは異なります。state は実際には React 自体の中で「生存」しています。まるで棚に保管しているかのように、関数の外部で存在し続けます。React がコンポーネントを呼び出すとき、React はその特定のレンダーに対する state のスナップショットを提供します。あなたのコンポーネントは、props やイベントハンドラの新たな一式を揃えた JSX という形で UI のスナップショットを返し、それらはすべてその特定のレンダー時の state の値を使って計算されます！
1. stateの更新をReactに指示。（setState()によって指示）
1. Reactがstateを更新。
1. Reactがコンポーネントにstateのスナップショットを渡す。

- state をセットしても、それが本当に変更されるのは次回のレンダーである。
- イベントハンドラのコードが非同期であっても、レンダー内の state 変数の値は決して変わりません。
- React は、レンダー内の state の値を「固定」し、イベントハンドラ内で保持します。
- 変数やイベントハンドラは複数レンダーをまたいで「生き残る」ことはない。すべてのレンダーは固有のイベントハンドラを持つ。
- 各レンダー（およびその中の関数）からは、常に、React が そのレンダーに渡した state のスナップショットが「見える」。

## 一連のstateの更新をキューに入れる
- state をセットしても既存のレンダーの変数は変更されず、代わりに新しいレンダーが要求される。
- React は、イベントハンドラが完了してから state の更新を処理する。これをバッチ処理と呼ぶ。
- イベントハンドラ内のすべてのコードが実行されるまで、React は state の更新処理を待機します。
- React は、クリックのような意図的なイベントが複数回発生した場合、それらにまたがったバッチ処理までは行いません。各クリックは別々に処理されます。
- state セッタに渡すものを、以下のように考えることができます。
   - 更新用関数（例：n => n + 1）の場合、それがキューに追加されます。
   - それ以外の値（例：数値 5）の場合、ここまでのキューの内容を無視する ”5 に置き換えよ” のような命令を追加します。
   - イベントハンドラが完了した後、React は再レンダーをトリガします。再レンダー中に React はキューを処理します。アップデート関数はレンダー中に実行されるため、更新用関数は純関数である必要があり、結果だけを返すようにする必要があります。その中で state をセットしたり、他の副作用を実行したりしないでください。
- 命名規則: 対応する state 変数の頭文字を使って更新用関数の引数の名前を付けることが一般的。その他、state名やprevState名など。

## state内のオブジェクトの更新
- state として格納するすべての JavaScript オブジェクトは読み取り専用として扱う必要があります。
- React の state 内にあるオブジェクトは技術的にはミュータブル（mutable, 書き換え可能）であるとしても、イミュータブルなものであるかのように扱うべきです。書き換えるのではなく、常に置き換えるべきです。
- ... スプレッド構文は「浅い (shallow)」ことに注意してください。これは 1 レベルの深さでのみコピーを行います。これは高速ですが、ネストされたプロパティを更新したい場合は、スプレッド構文を複数回使用する必要があるということでもあります。

### オブジェクトは実際にはネストされない
- オブジェクトの振る舞いを考える場合、「ネスト」という考え方は正確ではありません。コードが実行されてしまえば「ネストされた」オブジェクトというものは存在しません。実際には、2 つの異なるオブジェクトを見ているだけです。あくまで別々のオブジェクトであり、プロパティで互いを「参照している」のです。
- state にオブジェクトを格納する場合、それらをミューテートしてもレンダーがトリガされない。それは過去のレンダー内の state の「スナップショット」を書き換えているだけである。
- オブジェクトを書き換えるのではなく、代わりに新たなバージョンのオブジェクトを作成して、その新しいバージョンを新しい値として state をセットすることで再レンダーをトリガする。
- {...obj, something: 'newValue'} というオブジェクトスプレッド構文を使ってオブジェクトのコピーを作成できる。

## stateを使って入力に反応する
- 宣言型プログラミングとは、UI を細かく管理する（命令型）のではなく、視覚状態ごとに UI を記述することを意味する。
- コンポーネントを開発するとき：
   1. コンポーネントの視覚状態をすべて特定する。
   1. 状態を変更するための人間およびコンピュータのトリガを決定する。
   1. useState で state をモデル化する。
   1. バグや矛盾を避けるため、不必要な state を削除する。
   1. state を設定するためのイベントハンドラを接続する。

## state構造の選択
- 2 つの state 変数が常に一緒に更新される場合は、それらを 1 つにまとめることを検討する。
- 「ありえない」state を作成しないよう、state 変数を注意深く選択する。
- state は、更新時に間違いが発生しづらいやり方で構成する。
- 冗長で重複した state を避け、同期する必要がないようにする。
- 意図的に更新されないようにしたい場合を除き、props を state にコピーしない。
- 項目選択のような UI パターンにおいては、state にオブジェクト自体ではなく ID またはインデックスを保持する。
- 深くネストされた state の更新が複雑な場合は、フラット化を試す。

## コンポーネント間でstateを共有する
- コンポーネントを書くときには、その中のどの情報を（props で）制御し、どの情報を（state を使うことで）制御しないのかを検討してください。しかし後で考えを変えてリファクタリングすることはいつでも可能です。
- 2 つのコンポーネントを協調動作させたい場合は、state を共通の親に移動する。
- 次に、その共通の親から props 経由で情報を下に渡す。
- 最後に、子が親の state を変更できるよう、イベントハンドラを下に渡す。

## stateの保持とリセット
- React は、同じコンポーネントが同じ位置でレンダーされている限り、state を保持する。
- state は JSX タグに保持されるのではない。JSX を置くツリー内の位置に関連付けられている。
- あなたの関数内で条件分岐がどのように書かれているか、React には分かりません。React に「見える」のは、返されるツリーだけです。
- 再レンダー間で state を維持したい場合、ツリーの構造はレンダー間で「合致」する必要があります。
- 異なる key を与えることで、サブツリーの state をリセットするよう強制することができる。
- コンポーネント定義をネストさせてはいけない。さもないと state がリセットされてしまう。
- React はあなたの UI のコンポーネント構造をレンダーツリーとしてビルドします。コンポーネントに state を与えると、その state はそのコンポーネントの内部で「生存」しているように思えるかもしれません。しかし、実際には state は React の中に保持されています。React は、「レンダーツリー内でそのコンポーネントがどの位置にあるか」に基づいて、保持している各 state を正しいコンポーネントに関連付けます。

stateが共有されている例
```jsx
{isFancy ? (
   <Counter isFancy={true} /> 
) : (
   <Counter isFancy={false} /> 
)}
```
stateがリセットされる例
```jsx
{isFancy ? (
   <div>
      <Counter isFancy={true} /> 
   </div>
) : (
   <section>
      <Counter isFancy={false} />
   </section>
)}
```
```jsx
{isPlayerA &&
   <Counter person="Taylor" />
}
{!isPlayerA &&
   <Counter person="Sarah" />
}
```
```jsx
{isPlayerA ? (
   <Counter key="Taylor" person="Taylor" />
) : (
   <Counter key="Sarah" person="Sarah" />
)}
```

### 削除されたstateの保持
表示されなくなったコンポーネントの state を「生かしておく」方法はいくつかあります。
- 現在のチャットだけでなくすべてのチャットをレンダーしておき、CSS で残りのすべてのチャットを非表示にすることができます。チャットはツリーから削除されないため、ローカル state も保持されます。この解決策はシンプルな UI では適していますが、非表示のツリーが大きく DOM ノードがたくさん含まれている場合は非常に遅くなります。
- state をリフトアップすることで、各送信先に対応する書きかけのメッセージを親コンポーネントで保持することができます。この方法では、重要な情報を保持しているのは親の方なので、子コンポーネントが削除されても問題ありません。これが最も一般的な解決策です。
- また、React の state に加えて別の情報源を利用することもできます。例えば、ユーザがページを誤って閉じたとしてもメッセージの下書きが保持されるようにしたいでしょう。これを実装するために、Chat コンポーネントが localStorage から読み込んで state を初期化し、下書きを保存するようにできます。
どの戦略を選ぶ場合でも、Alice とのチャットと Bob とのチャットは概念的には異なるものなので、現在の送信先に基づいて <Chat> ツリーに key を付与することは妥当です。

## stateロジックをreducerに抽出する
- リデューサにより書くコードの量は少し増えるが、デバッグやテストに有用である。
- リデューサはレンダー中に実行されます！（アクションは次のレンダーまでキューに入れられます。）つまりリデューサはコンポーネントに依存しない純関数でなければならない。useStateと同様に、オブジェクトや配列をミューテーション（書き換え）せずに更新する必要があります。
- 各アクションは、複数データの更新を伴う場合であっても単一のユーザ操作を記述するようにします。
- Immer を使えば、ミューテーション型のスタイルでリデューサを書ける。

### reducerとは
- リデューサを使った state 管理は state を直接セットするのとは少し異なります。React に対して state をセットして「何をするか」を指示するのではなく、イベントハンドラから「アクション」をディスパッチすることで「ユーザが何をしたか」を指定します。（state の更新ロジックは別の場所に書きます！）つまりイベントハンドラで「tasks をセットする」のではなく、「タスクを追加/変更/削除した」というアクションのディスパッチを行います。何が起こったかを説明する名前を使う。
- 配列で行うことができる reduce() という操作にちなんで名付けられています。reduce() 操作とは、配列を受け取り、多くの値を 1 つの値に「まとめる」ことができるものです。ここで reduce に渡している関数が “リデューサ” と呼ばれるものです。これは「ここまでの結果」と「現在の要素」を受け取り、「次の結果」を返す関数です。React のリデューサも同じアイディアを用いています。「ここまでの state」と「アクション」を受け取り、「次の state」を返します。このようにして、経時的に発生する複数のアクションを 1 つの state に「まとめて」いるわけです。
- useReducerフックは2つの引数（reducer関数、初期state）を取り、state値とdispatch関数（ユーザアクションをリデューサに「ディスパッチ」する）を返す。

### useState から useReducer への移行
1. stateをセットするイベントハンドラをアクションのディスパッチに置き換える。
1. state とアクションから次の state を返すリデューサ関数を書く。
1. コンポーネントからリデューサを使用する。（useState を useReducer に置き換える。）

### switch文
- 各 case ブロックを { と } の波括弧で囲むことをお勧めします。これにより、異なる case の中で宣言された変数が互いに衝突するのを防ぐことができます。また、case は通常 return で終わるべきです。return を忘れると、コードが次の case に「流れて」してしまい、誤りが発生することがあります！

## コンテクストで深くデータを受け渡す
コンテクストにより、コンポーネントがそれ以下のツリー全体に情報を提供できる。
コンテクストを使うには：
export const MyContext = createContext(defaultValue) を使用して作成およびエクスポートする。
フックに useContext(MyContext) のようにコンテクストを渡せば、どんな深い子コンポーネントからも値が読み取れる。
コンテクストの値を提供するには子要素を <MyContext.Provider value={...}> でラップする。
コンテクストは中間コンポーネントを貫通する。
コンテクストを使えば、「周囲に適応する」コンポーネントが書ける。
コンテクストを使用する前に、props を渡すか、children として JSX を渡す方法を検討してみる。

### コンテクストを検討する前の検討
- まずは props を渡す方法から始めましょう。ちょっと凝ったコンポーネントであれば、多くの props を多くのコンポーネントを通して受け渡すことは珍しくありません。退屈な仕事に感じるかもしれませんが、どのコンポーネントがどのデータを使っているかが非常に明確になります！ コードをメンテナンスする人は、props を使ってデータの流れが明確に表現されていることに感謝するでしょう。
- コンポーネントを抽出して、children を JSX として渡す方法を検討しましょう。もし、何らかのデータを、それを必要とせずただ下に流すだけの中間コンポーネントを何層も経由して受け渡ししているような場合、何かコンポーネントを抽出するのを忘れているということかもしれません。たとえば、<Layout posts={posts} /> のような形で、データを直接使わないビジュアルコンポーネントに post のようなデータを渡しているのかもしれません。代わりに、Layout は children を props として受け取るようにし、<Layout><Posts posts={posts} /></Layout> のようにレンダーしてみましょう。これにより、データを指定するコンポーネントとそれを必要とするコンポーネントの間のレイヤ数が減ります。

### コンテクストの用途
コンテクストで扱う値は静的なものとは限りません。次のレンダーで異なる値を渡すと、React はその下でそれを必要しているすべてのコンポーネントを更新します！ これがコンテクストが state と一緒によく使われる理由です。
一般的に、ある情報が、ツリーの様々な部分にある離れたコンポーネントによって必要とされている場合、コンテクストが役立つというサインです。
- テーマ：例えばダークモードのように、アプリの外見をユーザが変更できる場合は、アプリのトップレベルにコンテクストプロバイダを配置し、外観を変化させる必要があるコンポーネントでそのコンテクストを使用します。
- 現在のアカウント：多くのコンポーネントは、現在ログインしているユーザを知る必要があります。それをコンテクストに入れることで、ツリーのどこからでも読み取りが容易になります。一部のアプリでは、複数のアカウントを同時に操作できます（例：別のユーザとしてコメントを残す）。このような場合、別の現在アカウントを指定したプロバイダをネストして、UI の一部をラップすることが有用です。
- ルーティング：ほとんどのルーティングソリューションは、現在のルートを保持するために内部でコンテクストを使用しています。これが、自身がアクティブかどうかをすべてのリンクが「知っている」理由です。独自のルータを構築する場合は自分でもこれを行いたいでしょう。
- state 管理：アプリが大きくなると、アプリのトップ近くに大量の state が集まってくることがあります。下の遠いところにある多くのコンポーネントがその state 変更する必要があるかもしれません。リデューサとコンテクストを一緒に使用することは一般的であり、これにより大変な手間をかけずに、複雑な state を離れたコンポーネントへ受け渡すことができます。

## reducerとcontextでスケールアップ
- リデューサとコンテクストを組み合わせることで、任意のコンポーネントが上位の state を読み取り、更新できるようになる。
- 下位のコンポーネントに state とディスパッチ関数を提供するには以下の手順に従う。
   - state 用とディスパッチ関数用の 2 つのコンテクストを作成する。
   - リデューサを使うコンポーネントから両方のコンテクストを提供する。
   - それらを読む必要があるコンポーネントからコンテクストを使用する。
- すべての繋ぎ込みコードを 1 つのファイルに移動することで、コンポーネントをさらに整理することができる。
   - コンテクストを提供する TasksProvider のようなコンポーネントをエクスポートする。
   - コンテクストから情報を読むためのカスタムフックである useTasks や useTasksDispatch をエクスポートすることもできる。
- アプリ内で、このようなコンテクストとリデューサのペアを多く作ることができる。

## refで値を参照する
- ref は、レンダーに使用されない値を保持するための避難ハッチである。これは頻繁には必要ない。
- ref は、current という単一のプロパティを持つプレーンな JavaScript オブジェクトであり、読み取りや書き込みができる。
- useRef フックを呼び出すことで、React に ref を渡してもらう。
- state と同様に、ref はコンポーネントの再レンダー間で情報を保持することができる。
- state とは異なり、ref の current 値をセットしても再レンダーはトリガされない。
- レンダー中に ref.current を読み書きしてはならない。それをするとコンポーネントが予測困難になる。

### refを使うタイミング
通常、ref を使用するのは、コンポーネントが React の外に「踏み出して」、外部 API（多くの場合はコンポーネントの外観に影響を与えないブラウザ API）と通信する必要がある場合です。以下は、そのような稀な状況の例です。
- タイムアウト ID の保存。
- DOM 要素の保存と操作。これについては次のページで取り上げます。
- JSX を計算するために必要ではないその他のオブジェクトの保存。
コンポーネントが値を保存する必要があるがそれがレンダーロジックに影響しないという場合は、ref を選択してください。

## refでDOMを操作する
- ref は一般的な概念だが、ほとんどの場合、DOM 要素を保持するために使用する。
- <div ref={myRef}> のように渡すことで、React に DOM ノードを myRef.current に入れるよう指示する。
- 通常、フォーカス、スクロール、または DOM 要素の測定などの非破壊的なアクションに ref を使用する。
- コンポーネントはデフォルトでは内部の DOM ノードを公開しない。forwardRef を使用して特定のノードに 2 番目の ref 引数を渡すことで、DOM ノードの公開を明示的に許可する。
- React によって管理される DOM ノードの変更を避ける。
- React によって管理される DOM ノードをどうしても変更する場合は、React が更新する理由のない部分のみ変更する。

### ref コールバックを使って ref のリストを管理する 
- ref 属性に関数を渡すことです。これは、ref コールバック と呼ばれます。React は、ref を設定するタイミングで DOM ノードを引数にして ref コールバックを呼び出し、クリアするタイミングでは null を引数にして呼び出します。これにより、独自の配列や Map を保持し、インデックスや ID のようなもので任意の ref にアクセスできるようになります。

## カスタムフックでロジックを再利用する
- カスタムフックを使ってコンポーネント間でロジックを共有できる。
- カスタムフックの名前は use で始めて大文字を続ける必要がある。
- カスタムフックは state 自体ではなく、state を使うロジックを共有する。
- あるフックから別のフックにリアクティブな値を渡すことができ、それらは最新の状態に保たれる。
- すべてのフックはコンポーネントが再レンダーされるたびに再実行される。
- カスタムフックのコードは、コンポーネントコードと同様に純粋である必要がある。
- カスタムフックが受け取るイベントハンドラはエフェクトイベントにラップする。
- useMount のようなカスタムフックを作成してはいけない。常に目的は具体的なものにする。
- コードの境界をどこにどのように置くかはあなたが決定する。

- コンポーネント間のロジックの重複が減りました。さらに重要なのは、コンポーネント内のコードが、「オンラインステータスを使用 (use) する」という、何をしたいのかの記述になっているということです。どのようにして実現するのか（ブラウザのイベントに登録する）ではありません。
ロジックをカスタムフックに抽出することで、外部システムやブラウザ API とのやり取りに関する面倒な詳細を隠蔽することができます。あなたのコンポーネントのコードは、実装方法ではなく意図を表現するようになるのです。

React コンポーネントの名前は大文字で始まる必要があります。例えば、StatusBar や SaveButton などです。React コンポーネントは、JSX のような、React が表示方法を知っているものを返す必要もあります。
フックの名前は use で始めて大文字を続ける必要があります。例えば、useState（組み込みのもの）や useOnlineStatus（上述のようなカスタムのもの）などです。フックは任意の値を返すことができます。
この慣習により、コンポーネントを見るだけで、その中の state、エフェクト、その他の React 機能がどこに「隠れている」可能性があるか、常に把握できることが保証されます。

カスタムフックは state 自体ではなく、state を使うロジックを共有する 
前の例では、ネットワークをオンまたはオフに切り替えると、両方のコンポーネントが同時に更新されました。しかし、isOnline という単一の state 変数がそれらの間で共有されていると考えるのは間違いです。
カスタムフックは、state 自体ではなく、state を扱うロジックを共有できるようにするためのものです。フックの呼び出しは、同じフックの他の場所からの呼び出しとは完全に独立しています。

カスタムフック内のコードは、コンポーネントの再レンダーごとに実行されます。そのため、コンポーネントと同様に、カスタムフックは純粋である必要があります。カスタムフックのコードは、コンポーネントの本体の一部だと考えてください！
カスタムフックはコンポーネントと一緒に再レンダーされるため、常に最新の props と state を受け取ります。

良いカスタムフックとは、動作を制約することで呼び出し側のコードをより宣言的にするものです。

エフェクトは “避難ハッチ” です。「React の外に踏み出す」必要があり、当該ユースケースに対してより良い組み込みのソリューションがない場合に使用するものです。長期的な React チームの目標は、より具体的な問題に対してより具体的なソリューションを提供することで、アプリ内のエフェクトの数を最小限に減らすことです。エフェクトをカスタムフックにラップしておくことで、これらのソリューションが利用可能になったときにコードのアップグレードが容易になります。

カスタムフックにエフェクトをラップすることが有益であるもうひとつの理由です。

エフェクトに出入りするデータの流れが非常に明確になる。
コンポーネントがエフェクトの実装そのものではなく、意図にフォーカスできるようになる。
React が新しい機能を追加したときに、コンポーネントを変更せずにエフェクトを削除できるようになる。

抽出したコードこそが「外部システム」となります。これにより、その React 外に移動したシステムにメッセージを送るだけでよくなるため、エフェクトはシンプルに保たれるでしょう。

## エフェクトを使って同期を行う
- イベントとは異なり、エフェクトは特定のユーザ操作ではなく、レンダー自体によって引き起こされる。
- エフェクトを使い、コンポーネントを外部システム（サードパーティ API、ネットワークなど）と同期させることができる。
- デフォルトでは、エフェクトは毎回のレンダー（初回も含む）の後に実行される。
- すべての依存値が前回のレンダー時と同じ値である場合、React はエフェクトをスキップする。
- 依存値は「選ぶ」類のものではない。それはエフェクト内のコードによって決定される。
- 空の依存配列 ([]) は、コンポーネントが「マウント」される、つまり画面に追加されることに対応する。
- Strict Mode では、React はコンポーネントを 2 回マウント（開発環境のみ！）して、エフェクトのストレステストを行う。
- エフェクトが再マウントにより壊れる場合、クリーンアップ関数を実装する必要がある。
- React は、次のエフェクトが実行される前とアンマウント中に、クリーンアップ関数を呼び出す。
- DOM の更新をエフェクトでラップすることで、React が先にまず画面を更新できるようになります。その後、エフェクトが実行されます。
- デフォルトでは、エフェクトは毎回のレンダーの後に実行される。

## エフェクトは必要ないかもしれない
- レンダー中に計算できるものであれば、エフェクトは必要ない。
- 重たい計算をキャッシュするには、useEffect の代わりに useMemo を追加する。
- コンポーネントツリー全体の state をリセットするには、異なる key を渡す。
- prop の変更に応じて一部の state をリセットする場合、レンダー中に行う。
- コンポーネントが表示されたために実行されるコードはエフェクトに、それ以外はイベントハンドラに入れる。
- 複数のコンポーネントの state を更新する必要がある場合、単一のイベントで行うことが望ましい。
- 異なるコンポーネントの state 変数を同期しようと思った際は、常に state のリフトアップを検討する。
- エフェクトでのデータフェッチは可能だが、競合状態を回避するためにクリーンアップを実装する必要がある。

### useMemoとそれを使う基準
```javascript
const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
```
todos または filter のどちらかが変更されない限り、中の関数を再実行しないよう React に指示するものです。React は初回レンダー時に getFilteredTodos() の返り値を覚えておきます。次回以降のレンダーでは、todos または filter が異なるかどうかをチェックします。前回と同じ場合、useMemo は最後に格納した結果を返します。異なる場合、React は再び中の関数を呼び出し、その結果を格納します。

useMemo でラップする関数はレンダー中に実行されるため、純粋 (pure) な計算に対してのみ機能します。

```javascript
console.time('filter array');
const visibleTodos = getFilteredTodos(todos, filter);
console.timeEnd('filter array');
```
```javascript
console.time('filter array');
const visibleTodos = useMemo(() => {
  return getFilteredTodos(todos, filter); // Skipped if todos and filter haven't changed
}, [todos, filter]);
console.timeEnd('filter array');
```

### propsが変更されたときすべてのstateをリセットする
通常、React は同じコンポーネントが同じ場所でレンダーされるときに state を保持します。userId を Profile コンポーネントの key として渡すことで、異なる userId を持つ 2 つの Profile コンポーネントを、state を共有すべきでない 2 つの異なるコンポーネントとして React に扱わせることができます。（userId となるようセットした）key が変更されるたびに、React は DOM を再作成し、Profile コンポーネントとそのすべての子コンポーネントの state をリセットします。これで、プロフィール間を移動するときに comment フィールドが自動的にクリアされるようになります。

### イベントハンドラとエフェクトのどちらにロジックを入れるべきか選択
ユーザの観点からそれがどのようなロジックなのかを自問自答するようにしましょう。そのロジックが特定のユーザ操作によって引き起こされる場合は、イベントハンドラに保持します。ユーザが画面上でコンポーネントを見ることによって引き起こされる場合は、エフェクトに保持します。

## others
Viewタグ、Textタグはそれぞれdivタグ、pタグのようなもの。
ほとんどのCoreComponentsはpropsによってカスタマイズ可能。（Imageコンポーネントのsourceなど）


# hooks

## useState
stateとstate更新関数を返すフック。
stateは画面に表示するデータやUIの状態。アプリケーションが保持している情報。
state管理では、stateの保持とstateの更新を行う。
stateの変更により再レンダーを行う。
複数のstateをひとつのオブジェクトでまとめることもできる。

useStateフックで初期値として関数を設定する方法は、遅延初期化（Lazy initialization）。初期状態の計算に高コストがかかる場合や、初期状態が副作用を伴って設定されるべき場合に特に有効。

## useEffect
コンポーネントに副作用（Reactから生成されたDOMの変更、API通信、非同期処理など）を追加する。
コンポーネントのレンダー後やアンマウント（コンポーネント廃棄）後に副作用を実行する。
引数の渡し方によって、毎回実行したり、一度だけ実行させたり、特定の値が変更された時だけ実行てきる。

## useRef
DOMの参照や値の保持をする。useStateとは異なり、useRefで生成した値を更新しても再レンダーされない。レンダーに関係ないstateを扱いたい時に利用。

## React.memo
コンポーネントのレンダー結果をメモ化する。
レンダーコストの高いコンポーネントや、頻繁に再レンダーされるコンポーネント内の子コンポーネントの再レンダーをスキップしてパフォーマンスを上げる。
propsの等価性をチェックして再レンダーを判断する。
useCallback、useMemo と併せて使うことが多い。

props がオブジェクト・配列・関数の場合は、浅い比較により別オブジェクトであると判断されるため、親コンポーネントで props を単純化するか、または props をメモ化する。

## useCallback
### useCallback で関数をキャッシュすることが有用なケース
- それを memo でラップされたコンポーネントに props として渡すケース。この場合は、値が変化していない場合には再レンダーをスキップしたいでしょう。メモ化することで、依存値が異なる場合にのみコンポーネントを再レンダーさせることができます。
- あなたが渡している関数が、後で何らかのフックの依存値として使用されるケース。たとえば、他の useCallback でラップされた関数がそれに依存している、または useEffect からこの関数に依存しているケースです。

## useMemo
 - 引数を取らない順関数を第一引数に指定する。この関数の実行結果をキャッシュする。

### useMemo を利用した最適化が有用なケース
- useMemo で行う計算が著しく遅く、かつ、その依存値がほとんど変化しない場合。
- 計算した値を、memo でラップされたコンポーネントの props に渡す場合。この場合は、値が変化していない場合には再レンダーをスキップしたいでしょう。メモ化することで、依存値が異なる場合にのみコンポーネントを再レンダーさせることができます。
- その値が、後で何らかのフックの依存値として使用されるケース。例えば、別の useMemo の計算結果がその値に依存している場合や、useEffect がその値に依存している場合などです。

## useReducer
stateとdispatch（actionを送信する関数）を返すフック。
複雑なstate更新を行う時に使うと良い？

## useContext

## カスタムフック
コンポーネントから切り出したロジックを定義した関数。
カスタムフックは、ロジックの再利用や関心の分離を実現するためにReactで利用されます。以下は、カスタムフックを使用する典型的な場面の一部です：

1. **ロジックの再利用**:
   複数のコンポーネントで共通のロジックを使用する場合、そのロジックをカスタムフックとして切り出し、再利用することができます。

2. **外部データの取得**:
   API呼び出しやWebSocketの接続など、外部データの取得とその状態管理をカスタムフック内で行うことがよくあります。

3. **イベントリスナの管理**:
   ウィンドウのリサイズやキープレスなど、特定のイベントリスナを設定・削除するロジックをカスタムフックでまとめることができます。

4. **フォームの管理**:
   フォームの入力状態管理やバリデーションのロジックをカスタムフックで一元化することができます。

5. **サードパーティのライブラリとの統合**:
   特定のサードパーティのライブラリをReactのコンポーネントで使用する際のロジックをカスタムフック内でカプセル化することがよくあります。

6. **アニメーションやトランジション**:
   アニメーションの状態や進行を制御するロジックをカスタムフックとして切り出すことができます。

7. **グローバルな状態の購読**:
   グローバルな状態（例: ReduxやMobXのような状態管理ライブラリ）を購読し、その状態をコンポーネントで利用しやすくするためのカスタムフックを作成することができます。

8. **副作用の管理**:
   一貫した副作用の実行やクリーンアップのロジックをカスタムフックで管理することができます。

これらの場面では、カスタムフックを使用することで、コードの再利用性、読みやすさ、メンテナンス性が向上します。また、カスタムフックは関数ベースのコンポーネントとの相性が良く、Hooksの導入以降、Reactの開発スタイルとして一般的になっています。


# クラスコンポーネント
* reactモジュールのComponentクラスを継承
* renderメソッドで描画内容（React要素）を返す
* ライフサイクルを理解するために知っておくとよい。

# Export

## `export` (名前付きエクスポート)

- **名前付きエクスポート**：この方法を使用すると、複数の値やコンポーネントを同一ファイルからエクスポートできます。
- **インポート方法**：インポートする際は、エクスポートされた名前を`{}`内に記載してインポートします。例：`import { MyComponent } from './MyComponent';`
- **柔軟性**：一つのファイルから複数の関数やコンポーネントをエクスポートし、必要なものだけを選んでインポートできるため、柔軟性があります。

## `export default` (デフォルトエクスポート)

- **デフォルトエクスポート**：各ファイルには一つの`export default`が存在できます。これはそのファイルの「主要な」エクスポートと見なされます。
- **インポート方法**：デフォルトエクスポートされた値は、`{}`なしで直接インポートできます。また、インポートする際に任意の名前を与えることができます。例：`import MyComponent from './MyComponent';`
- **簡潔さ**：通常は、ファイルごとに一つの主要なコンポーネントや機能がある場合に使われ、インポートが簡単になります。

### 使用例

以下の例では、一つのファイルから複数の関数やコンポーネントをエクスポートしています。

```javascript
// MyComponent.js

export const MyFunction = () => {
  // 何かの関数
};

export const AnotherFunction = () => {
  // 別の関数
};

const MyComponent = () => {
  // コンポーネントの定義
};

export default MyComponent;
```

これらをインポートするには：

```javascript
import MyComponent, { MyFunction, AnotherFunction } from './MyComponent';
```

# ライフサイクル
ライフサイクルはコンポーネントが生成されてから削除されるまでの一連の流れ
内部のstateが更新された時、もしくは親コンポーネントから新しいpropsが渡された際にコンポーネントの更新処理が起きる。

mounting
コンポーネントが配置される期間
初期化→レンダリング→マウント後処理

updating
コンポーネントが変更される期間
レンダリング→更新後処理

unmounting
コンポーネントが破棄される期間
破棄前の処理

Reactの再レンダリングの流れは、以下のようになります：

1. **State/Propsの変更**:
   Reactのコンポーネントは、stateやpropsが変更されたときに再レンダリングされることが多いです。

2. **仮想DOMの生成**:
   コンポーネントが再レンダリングされると、Reactは新しい仮想DOMを生成します。これは実際のDOMとは異なり、メモリ上でのみ存在する軽量の表現です。

3. **差分検出（Diffing）**:
   Reactは新しい仮想DOMと前回の仮想DOMを比較して、どの部分が変更されたかを特定します。

4. **再描画（Reconciliation）**:
   差分をもとに、実際のDOMに必要な変更を適用します。このステップにより、DOMの更新が最適化され、必要最小限の変更のみが行われます。

5. **コンポーネントのライフサイクルメソッド**:
   一部のライフサイクルメソッド（例: `componentDidUpdate`）がこの再レンダリングの過程で呼び出されることもあります。

注意点:
- `shouldComponentUpdate`やReact.memoなどのオプティマイゼーション技術を利用することで、不要な再レンダリングを回避することができます。
- Hooksを使用している場合、`useEffect`や`useMemo`などのフックも再レンダリングの制御に影響することがあります。

Reactの再レンダリングの流れを理解することは、パフォーマンスの最適化やバグのトラブルシューティングに役立ちます。

もちろん、Reactのコンポーネントライフサイクルは、特定のフェーズにおいて何が起こっているのかを理解するためのキーです。クラスベースのコンポーネントに特有のものですが、Reactの進化と共にHooksが導入されたことで、関数ベースのコンポーネントでも同様のライフサイクル処理を模倣することができるようになりました。

クラスベースのコンポーネントにおける主なライフサイクルメソッドは以下のとおりです：

1. **マウント（Mounting）**:
   - `constructor()`: コンポーネントの初期化とstateの設定を行います。
   - `static getDerivedStateFromProps()`: propsからstateへの値のセットを行う場合に使います。
   - `render()`: コンポーネントを描画します。
   - `componentDidMount()`: コンポーネントがDOMにマウントされた後に実行される。API呼び出しやDOM操作、イベントリスナの追加などをここで行うことが多いです。

2. **更新（Updating）**:
   - `static getDerivedStateFromProps()`: 新しいpropsを受け取ったときに呼び出されます。
   - `shouldComponentUpdate()`: パフォーマンス最適化のために、再レンダリングをするべきかどうかを決めることができます。
   - `render()`: 再レンダリングを行います。
   - `getSnapshotBeforeUpdate()`: 更新前のDOMの状態や情報をキャッチするために使います。
   - `componentDidUpdate()`: コンポーネントが更新された後に呼び出される。新しいpropsやstateをもとに何らかの操作を行うことが多いです。

3. **アンマウント（Unmounting）**:
   - `componentWillUnmount()`: コンポーネントがDOMから削除される直前に実行される。イベントリスナの削除やクリーンアップ作業をここで行うことが多いです。

4. **エラーハンドリング**:
   - `static getDerivedStateFromError()`: 子コンポーネントでエラーが発生した場合に、エラー情報をもとにstateを更新するために使います。
   - `componentDidCatch()`: エラーロギングや特定のUIを表示するために使用します。

関数ベースのコンポーネントでは、`useEffect` フックを使って同様のライフサイクルイベントを模倣することができます。たとえば、`componentDidMount` と `componentWillUnmount` は `useEffect` でそれぞれの処理を書くことで再現できます。


# 再レンダリング
Reactのコンポーネントにおける状態遷移は主に、コンポーネントの内部状態（`state`）や外部から渡されるデータ（`props`）の変更を指します。この変更は、コンポーネントの再レンダリングを引き起こします。

以下に、Reactコンポーネントの状態遷移の概要とそのステップを説明します。

1. **初期化**:
   - コンポーネントのインスタンスが生成される際、`constructor`内で`state`の初期化が行われます。
   - コンポーネントは初めてのレンダリングを行い、画面に表示されます。

2. **propsの変更**:
   - 親コンポーネントから新しい`props`が渡されると、子コンポーネントの再レンダリングが引き起こされることがあります。
   - `getDerivedStateFromProps`が存在する場合、新しい`props`を元に`state`の更新を行うことができます。

3. **stateの変更**:
   - コンポーネント内部で`setState`メソッドや`useState`フックのセッター関数が呼び出されると、`state`が更新されます。
   - `state`の変更は再レンダリングを引き起こします。

4. **ユーザーインタラクション**:
   - ユーザーがボタンをクリックしたり、フォームの入力を行ったりすると、イベントハンドラがトリガーされます。
   - このイベントハンドラ内で`state`の変更や親コンポーネントへのコールバックの実行など、状態遷移の起点となるアクションが行われることが多いです。

5. **外部データの取得**:
   - API呼び出しの結果やWebSocketのメッセージなど、外部からのデータの受け取りが状態遷移の起点となることもあります。

6. **アンマウント**:
   - コンポーネントがDOMから削除される際、関連するリソースやイベントリスナのクリーンアップを行う必要があります。

これらの遷移は、Reactのコンポーネントライフサイクルやフックを使用して管理されます。適切なライフサイクルメソッドやフック内で状態遷移を制御することで、効率的でバグの少ないアプリケーションを実現することができます。


はい、`state`や`props`の変更以外にも、コンポーネントが再レンダリングされるケースはいくつか存在します。以下はその主なケースです：

1. **親コンポーネントの再レンダリング**:
   親コンポーネントが再レンダリングされると、子コンポーネントもデフォルトで再レンダリングされます。これは、子コンポーネントが`props`の変更を受け取らなくても発生します。

2. **`forceUpdate`メソッドの使用**:
   クラスコンポーネントには`forceUpdate`というメソッドが存在し、これを呼び出すと、コンポーネントは強制的に再レンダリングされます。

3. **コンテクストの変更**:
   `Context.Provider`の`value`が変更されたとき、そのコンテクストを購読しているコンポーネントは再レンダリングされます。

4. **不純なコンポーネント**:
   Reactはデフォルトではコンポーネントが純粋（pure）でないと仮定します。したがって、再レンダリングが頻繁に発生する可能性があります。`PureComponent`や`React.memo`を使用することで、この再レンダリングを最適化することができます。

5. **Hooksの状態更新**:
   `useState`や`useReducer`などのHooksの状態更新関数を呼び出すと、関数コンポーネントは再レンダリングされます。

これらのケースを理解しておくことは、パフォーマンスの最適化や不要な再レンダリングを避けるために重要です。適切な最適化手段を適用することで、アプリケーションの効率を高めることができます。


4番の「不純なコンポーネント」に関する再レンダリングの説明は、コンポーネントが純粋であるか否かという概念に基づいています。ここでの「純粋」とは、同じpropsとstateが与えられた場合、常に同じ出力（レンダリング結果）を返すコンポーネントを指します。

Reactのデフォルトの動作は、コンポーネントが純粋でないと仮定するため、再レンダリングが頻繁に発生します。これは、Reactが`props`や`state`の浅い比較を行わないためです。

4番のケースでの再レンダリングが発生する主な理由は以下の通りです：

1. **新しいオブジェクトや配列の生成**:
   コンポーネントの`render`メソッド内や関数コンポーネントの本体内で新しいオブジェクトや配列を生成すると、そのオブジェクトや配列は毎回新しい参照として生成されます。そのため、親コンポーネントから子コンポーネントへこれを`props`として渡すと、子コンポーネントは再レンダリングされる可能性が高まります。

2. **関数の新しいインスタンスの生成**:
   同様に、コンポーネント内で新しい関数のインスタンスを生成すると、その関数は新しい参照として扱われます。これも不要な再レンダリングを引き起こす要因となります。

3. **親コンポーネントの再レンダリング**:
   親コンポーネントが再レンダリングされると、その子コンポーネントも再レンダリングされる可能性があります。ただし、子コンポーネントが純粋であると明示的に示されている場合（`React.PureComponent`や`React.memo`を使用している場合）は、この動作は最適化されます。

これらの不要な再レンダリングを避けるためには、コンポーネントの最適化や`React.memo`、`useMemo`、`useCallback`などのツールを使用して、参照の安定性を保つなどの対策を取ることが推奨されます。

はい、Reactでは親コンポーネントが再レンダリングされても、特定の条件下で子コンポーネントが再レンダリングされないケースが存在します。以下はそのケースをいくつか挙げます：

1. **PureComponentまたはReact.memoを使用する**: 子コンポーネントが`React.PureComponent`を継承しているか、または`React.memo`でラップされている場合、propsとstateが前のレンダリングと同じであれば、子コンポーネントは再レンダリングされません。

2. **stateとpropsが変更されていない**: 親コンポーネントが再レンダリングされたとしても、子コンポーネントに渡されるpropsやstateが変更されていない場合、子コンポーネントの再レンダリングは発生しない可能性があります。

3. **shouldComponentUpdateを使用する**: 子コンポーネントで`shouldComponentUpdate`ライフサイクルメソッドを使用し、そのメソッドが`false`を返す場合、子コンポーネントは再レンダリングされません。

これらの方法を使用して、不要な子コンポーネントの再レンダリングを防ぐことで、アプリケーションのパフォーマンスを向上させることができます。ただし、これらの方法を過度に使用すると、アプリケーションの動作に予期しない問題が生じる可能性があるため、注意が必要です。


`onClick`でカスタムフックを使用するボタンコンポーネントが押下時に再レンダリングされるかどうかは、そのカスタムフックの中身やボタンコンポーネントの他のプロパティやステートに依存します。

以下は考慮すべきシナリオです：

1. **カスタムフックが内部でステートを更新する**: カスタムフックが内部でuseStateやuseReducerなどのステートを更新するロジックを持っている場合、そのステートが変更されると、ボタンコンポーネントは再レンダリングされます。

2. **親コンポーネントのステート/プロップスが変わる**: ボタンコンポーネントが親コンポーネントからのプロップスに依存している場合、それらのプロップスが変わるとボタンも再レンダリングされる可能性があります。

3. **カスタムフックが新しい関数/オブジェクトを返す**: カスタムフックが常に新しい関数やオブジェクトを返す場合、ボタンコンポーネントはそれによって再レンダリングがトリガーされる可能性があります。これを防ぐためには、`useCallback`や`useMemo`をカスタムフック内で使用すると良いでしょう。

4. **ボタン自体のステートが変更されない**: もしボタンコンポーネントの内部ステートや受け取るプロップスが変更されない場合、ボタンは再レンダリングされないかもしれません。

結論として、`onClick`でカスタムフックを使用するだけでは、ボタンが再レンダリングされるとは限りません。カスタムフックの動作や、ボタンのステートやプロップスの変更によって再レンダリングが決まります。


カスタムフック内に`useState`が含まれており、そのフックの処理内で必ずステートが更新される場合、そのステートを使用しているコンポーネントは再レンダリングされるはずです。

しかし、以下のような特殊な状況や理由で再レンダリングが発生しない場合も考えられます：

1. **新しいステートの値が前のステートの値と同じ**: Reactの`useState`は参照の同一性ではなく、シャロー比較を行います。したがって、新しいステートの値が前回と同じであれば、再レンダリングはトリガーされません。

2. **子コンポーネントの再レンダリングをブロック**: 子コンポーネントに`React.memo`や`shouldComponentUpdate`を使用している場合、再レンダリングがブロックされることがあります。

3. **Reactのバッチ処理による更新のマージ**: 連続して多数のステート更新が行われる場合、Reactはこれらの更新をバッチ処理し、1回の再レンダリングでこれらの変更を適用することがあります。

4. **エラーや例外**: カスタムフックやコンポーネント内で何らかのエラーや例外が発生し、それにより更新が完了しない場合が考えられます。

通常、ステートの更新があると再レンダリングがトリガーされるのですが、上記のような特定の条件下では再レンダリングが発生しないことが考えられます。

# state
Reactで`state`に設定するものは、コンポーネント内部でのデータの動的な変化や状態を表現するものです。以下は、`state`に設定される典型的な例をいくつか挙げます：

1. **ユーザー入力**: フォームのテキスト入力、選択ボックスの選択、チェックボックスの状態など、ユーザーからの入力に基づくデータ。

   ```javascript
   const [inputValue, setInputValue] = useState('');
   ```

2. **表示・非表示のフラグ**: モーダルやドロップダウンメニュー、トースト通知などの表示状態。

   ```javascript
   const [isModalOpen, setModalOpen] = useState(false);
   ```

3. **データの取得結果**: APIからのデータ取得やデータベースのクエリ結果。

   ```javascript
   const [userData, setUserData] = useState(null);
   ```

4. **ページネーション**: 現在のページ番号や表示するアイテムの数。

   ```javascript
   const [currentPage, setCurrentPage] = useState(1);
   ```

5. **アニメーション**: アニメーションの進行状態や完了フラグ。

   ```javascript
   const [animationProgress, setAnimationProgress] = useState(0);
   ```

6. **カウンターやタイマー**: 値が時間経過やユーザー操作によって増減する数字。

   ```javascript
   const [counter, setCounter] = useState(0);
   ```

7. **エラーや通知メッセージ**: API呼び出しのエラー情報やユーザーへの通知メッセージ。

   ```javascript
   const [errorMessage, setErrorMessage] = useState('');
   ```

8. **ユーザーのインタラクション**: タブの選択、スライダーの位置、ドラッグ&ドロップの状態など。

   ```javascript
   const [selectedTab, setSelectedTab] = useState('overview');
   ```

これらは一部の例に過ぎません。実際には、アプリケーションの要件や動作に合わせて、さまざまなデータや状態を`state`として管理することがあります。

## state の値を利用する関数

1. **関数内で直接 state を呼び出す場合**：
   - 関数がそのコンポーネント内の特定の state に密接に依存しているとき、またはその関数がコンポーネント外では使われない場合は、関数内で直接 state を呼び出す方が自然です。
   - これにより、関数の使い方がシンプルになり、コンポーネントの内部的な詳細を抽象化することができます。

2. **state を引数として受け取る場合**：
   - 関数がより汎用的で、複数の異なる state や複数のコンポーネントで再利用される可能性がある場合、state を引数として受け取る方が適切です。
   - これにより、関数は特定の state に依存しなくなり、テストや再利用が容易になります。

具体的な状況に応じて、どちらのアプローチが最適かを判断することが重要です。関数の再利用性とコンポーネントのエンカプセレーション（カプセル化）のバランスを取ることが鍵となります。

## シャローコピー
JavaScriptの`slice`メソッドは配列のシャローコピーを作成します。これは、新しい配列が元の配列の要素への参照（オブジェクトや配列など）をコピーするが、要素自体はコピーしないことを意味します。シャローコピーが有用な理由はいくつかあります：

1. **イミュータビリティ（不変性）**: Reactなどのライブラリでは、状態の不変性が重要です。状態を直接変更するのではなく、新しい状態オブジェクトを作成することで、Reactは変更を正しく検出し、適切にUIを更新できます。`slice`を使用して配列のコピーを作成することで、元の配列を変更せずに新しい配列を操作できます。

2. **パフォーマンス**: オブジェクトや配列の完全なディープコピーを作成すると、メモリ使用量と処理時間が増加します。シャローコピーは必要最低限のデータのみをコピーするため、より効率的です。

3. **参照の保持**: オブジェクトや他の複雑なデータ構造を含む配列では、これらの要素への参照を維持することがしばしば望ましいです。シャローコピーはこれらの参照を保持します。

Reactアプリケーションでは、これらの理由から`slice`がよく使われます。特に、状態を更新する際には、元の状態を直接変更するのではなく、新しい状態オブジェクトを作成することが重要です。

Reactでは、配列やオブジェクトなどの複合データ型がstateとして保持されている場合、そのstateを更新するには新しいオブジェクトまたは配列を作成する必要があります。ここでのポイントは、Reactはstateの変更を検出するために「浅い比較（shallow comparison）」を使用するということです。

シャローコピーされた配列は、新しい配列インスタンスを作成しますが、配列の内容（特にオブジェクトや配列などの参照型の要素）は元の配列のものと同じ参照を持ちます。Reactにおいては、この新しい配列インスタンスがstateの更新として認識されます。

- **配列のインスタンスが異なる**: `slice`などで作成された新しい配列は、元の配列とは異なるインスタンスです。Reactはこの新しいインスタンスを「変更されたstate」として認識し、それに応じて再レンダリングを行います。

- **配列の内容**: シャローコピーされた配列の要素は、元の配列の要素と同じ参照を持っています。これは、元の配列のオブジェクトや配列を直接変更した場合、シャローコピーされた配列でも同じ変更が見られることを意味します。ただし、Reactの観点からは、配列自体の「インスタンス」が変更されたことが重要であり、配列の内容が参照するオブジェクトの変更は直接的には追跡されません。

要するに、Reactにおいては、配列のシャローコピーはstateが変更されたと見なされ、それに基づいてコンポーネントは再レンダリングされます。しかし、シャローコピーにより配列の中身（特に参照型の要素）が直接変更されていない限り、それらの内容は同じままです。状態の変更を確実に検出し、適切にUIを更新するためには、不変性を保つためにシャローコピーを利用するのが一般的な手法です。


# クラスコンポーネント→関数コンポーネント
クラスコンポーネントを関数コンポーネントに置き換える際に考慮すべき主要なポイントは以下の通りです：

1. **状態管理の変換**：
   - クラスコンポーネントでは `this.state` と `this.setState` を使用して状態を管理しますが、関数コンポーネントでは `useState` フックを使います。

2. **ライフサイクルメソッドの置き換え**：
   - クラスコンポーネントのライフサイクルメソッド（`componentDidMount`、`componentDidUpdate`、`componentWillUnmount`）は、関数コンポーネントでは `useEffect` フックで置き換えられます。

3. **イベントハンドラの変更**：
   - クラスコンポーネントでのイベントハンドラ（例：`this.handleClick`）は、関数コンポーネント内で直接関数として定義されます。

4. **参照（Refs）の使用法の変更**：
   - クラスコンポーネントでの `this.refs` は、関数コンポーネントでは `useRef` フックを使用して管理します。

5. **コンテキストの利用**：
   - クラスコンポーネントでは `contextType` または `<Consumer>` コンポーネントを使用してコンテキストを利用しますが、関数コンポーネントでは `useContext` フックが使われます。

6. **その他のフックの利用**：
   - カスタムフック（自作のフック）を使用して、ロジックの再利用や抽象化を図ることができます。

7. **パフォーマンスの最適化**：
   - クラスコンポーネントの `shouldComponentUpdate` に相当するパフォーマンス最適化は、関数コンポーネントでは `React.memo` や `useMemo`、`useCallback` フックを使用して行います。

これらの変換を行うことで、クラスコンポーネントから関数コンポーネントへのスムーズな移行が可能になります。また、関数コンポーネントは一般的により簡潔で読みやすく、React のフックを活用してより宣言的なコードを書くことができるようになります。

# コンポーネント設計
## 設計パターン
* container / presentation component
* render props
* compound component
* high order component

## 機能追加の選択肢

- コンポジション（子コンポーネント、HOC）
- カスタムフック
- porps

## HOC と カスタムフックによるロジックの再利用

カスタムフックと高階コンポーネント（HOC）は、Reactで再利用可能なロジックをコンポーネント間で共有するための手段。

HOCの利点:
- UIの一貫性: HOCを使用すると、エラーやローディング状態のUIを一元管理できます。これにより、アプリケーション全体でUIの一貫性を保ちやすくなります。
- コードの重複削減: ローディング状態やエラー状態の処理をHOCに集約することで、各コンポーネントでの重複コードを減らすことができます。
- コンポーネントの責務分離: HOCにより、データ取得と状態管理のロジックをコンポーネントから分離し、ビジネスロジックやUIの構築に集中できます。

- 再利用性: 複数のコンポーネントが共通のロジックを共有しているが、そのロジックが状態やライフサイクルイベントに依存していない場合、HOCを使用するとコードの再利用性が向上する。例えば、多くの異なるコンポーネントにデータフェッチングやエラーハンドリングのロジックを適用したい場合、それらの機能をHOCに抽出して再利用することができる。
- 条件付きレンダリング: 特定の条件下でのみコンポーネントをレンダリングしたい場合、HOCはその条件ロジックを共通化して各コンポーネントから抽出する良い方法です。例えば、認証されたユーザーのみがアクセスできるコンポーネント群に対して、HOCを使って認証チェックを一箇所で行うことができます。
- レンダリングハイジャック: コンポーネントのレンダリング出力を変更したい場合、HOCを使用すると、元のコンポーネントを変更せずにレンダリングを変更することができます。これにより、ローディングインジケーターの追加やスタイリングの適用などが可能になります。

カスタムフックの利点:
- フックの合成: カスタムフックを使用すると、フックを合成して複数のフックから成る複雑なロジックを構築することが容易になります。
- 使いやすさ: カスタムフックは、Reactの関数コンポーネント内で直接使用できるため、HOCよりも使いやすいと感じる開発者もいます。
- テストのしやすさ: カスタムフックは独立したロジックの単位としてテストしやすく、HOCを使う場合に比べてテストの際の複雑さが減少することがあります。

ケースに応じた選択
- エラーとローディングのUIがアプリケーション全体で統一されている必要がある場合、HOCが適している可能性が高いです。HOCにより、これらのUIを一元管理でき、各コンポーネントでの重複を避けることができます。
- ロジックの再利用性やフックの合成に重点を置いている場合、カスタムフックの方が適しているかもしれません。特に、エラー処理やローディング状態の管理以外にも、多くの独立したロジックをコンポーネント間で共有したい場合は、カスタムフックが柔軟性を提供します。

## 子コンポーネントをハードコーディングするケースとchildren propsで受け取るケース
* レンダリングするコンポーネントが決まっていたり、カスタマイズさせる必要がない場合はハードコーディング。
* 拡張性、カスタマイズ性を優先する必要があればchildrenを利用。

