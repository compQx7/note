# Rust入門

## サンプルプログラム

```rust
// chrono::{NaiveDate, Duration, Datelike}: chronoクレートからNaiveDate（日付を扱うため）、Duration（時間の長さを扱うため）、Datelike（日付に関連するメソッドを提供するトレイト）をインポートしています。
use chrono::{NaiveDate, Duration, Datelike};
use std::fs::File;
// std::io::{self, Write}: 標準入出力（io）関連の機能と、出力（書き込み）機能を提供するWriteトレイトをインポートしています。
use std::io::{self, Write};

fn main() -> io::Result<()> {
    let input = "202402";
    // .unwrap()は、パースが成功した場合はその値を返し、失敗した場合はパニックを引き起こします。
    let year = &input[0..4].parse::<i32>().unwrap();
    let month = &input[4..6].parse::<u32>().unwrap();

    // .expect("Invalid date")で無効な日付が与えられた場合にプログラムがエラーメッセージを出して終了するようにしています
    let start_date = NaiveDate::from_ymd_opt(*year, *month, 1).expect("Invalid date");

    let mut current_date = start_date;

    // ファイルを作成
    // ?はエラーが発生した場合に早期に関数から抜ける（エラーを伝播する）ために使用されます。
    let mut file = File::create(format!("{}-diary.md", input))?;

    while current_date.month() == *month {
        writeln!(file, "# {}", current_date.format("%Y%m%d"))?;
        current_date += Duration::days(1); // 次の日に更新
    }

    Ok(())
}
```

## 基本構文

- `main`関数はRustプログラムのエントリーポイントとして自動的に認識される関数です。Rustプログラムが実行されると、最初に`main`関数が呼び出されます。
- `i32`と`u32`は型です。`i32`は32ビットの符号付き整数を表し、`u32`は32ビットの符号なし整数を表します。

## クレートとトレイト

- クレート: Rustのパッケージシステムにおける基本的なコンパイルユニットです。ライブラリや実行可能ファイルを生成するためのソースコードの集まりを指します。クレートは、関数、型、トレイトなどのRustの要素をカプセル化し、再利用可能な単位としてパッケージ化します。
- トレイト: Rustのトレイトは、特定の機能や振る舞いを定義するためのインターフェースのようなものです。トレイトを使用することで、異なる型に共通の振る舞いを実装することができます。これにより、ポリモーフィズムとインターフェースの契約を表現できます。
    - `Datelike`トレイトは、日付に関連するメソッドを提供するRustの`chrono`クレートに定義されています。このトレイトには、年（`.year()`）、月（`.month()`）、日（`.day()`）など、日付の各部分を取得するためのメソッドが含まれています。`Datelike`トレイトは、日付を扱う構造体やenumで実装され、これらの型に日付に関連する共通の振る舞いを提供します。例えば、`NaiveDate`、`NaiveDateTime`、`Date`、`DateTime`などの型で`Datelike`トレイトが使われています。

## Result型

- パニックは、Rustにおける実行時エラーの一種で、通常は回復不可能なエラーが発生したときに起こります。これは他の言語の「例外」と似ていますが、Rustでは「例外」よりも制御が難しく、通常はプログラムの即時終了を引き起こします。Rustでは、例外的な状況を扱うためにパニックの代わりに`Result`型を使うことが奨励されます。
- `unwrap`は、`Option`または`Result`型の値を処理するメソッドです。`Option`や`Result`が成功を表す値（`Some`や`Ok`）を持っている場合、`unwrap`はその値を取り出します。しかし、失敗を表す値（`None`や`Err`）が含まれている場合、`unwrap`はパニックを引き起こします。このため、`unwrap`の使用はエラーハンドリングが必要ない場合や、エラーが発生することが絶対にないと確信している場合に限定されるべきです。
    - `Option`型は、値が存在するかもしれないし、存在しないかもしれない状況を表すためのRustの列挙型です。これは他の言語のnull許容型に似ていますが、より型安全です。`Option`型は二つのバリアントを持ちます：`Some(T)`は値が存在することを表し、`None`は値が存在しないことを表します。これにより、Rustはnull参照の問題を防ぎ、コンパイル時に値の存在をチェックすることを強制します。
    - `Result`型は、操作が成功した場合とエラーが発生した場合の二つのアウトカムを表すために使用されるRustの列挙型です。`Result`型は、`Ok(T)`と`Err(E)`の二つのバリアントを持ちます。`Ok(T)`は操作が成功し、何らかの結果値`T`を含むことを表します。`Err(E)`は、何らかのエラー`E`が発生したことを表します。`Result`型を使用することで、Rustはエラー処理をより明示的にし、エラーハンドリングを強制することができます。
    - `Ok(())`は、`Result`型を使用している場合に、成功を表す値が特にない（つまり、値を返さないが成功したことを示したい）場合によく使われます。`Result`型は成功`Ok(T)`またはエラー`Err(E)`のいずれかを返す必要がありますが、成功した場合に特に返す値がない場合（例えば、何かの操作が成功したが、それによって特定の値が生成されない場合）、`()`（ユニット型）を使用して「何もない」ことを表します。
    - `()`はユニット型と呼ばれ、Rustで「何もない」または「空」を表すために使用されます。関数が何も返さない場合、実際には暗黙的にユニット型`()`を返していると考えることができます。
    - `Ok(())`は、操作が成功したが返すべき値がない場合に`Result`型を返すために使用されます。これは、エラーが可能性として存在するが、成功時には値を返す必要がない関数やメソッドでよく見られます。

- `mut`はmutable（変更可能な）変数を表します。Rustでは、デフォルトで変数はimmutable（不変）です。変数の値を変更可能にするためには、変数宣言時に`mut`キーワードを使用します。

## マクロ

- `format!`の後ろの`!`は、それがマクロであることを示します。Rustでは、関数とは異なり、マクロはコンパイル時にコードに展開されます。`format!`マクロは、文字列をフォーマットするために使われ、指定されたフォーマットに従って文字列を生成します。これは`println!`マクロに似ていますが、出力を画面に表示する代わりに文字列を返します。
    - マクロは、コードの生成と再利用を容易にするための強力なツールです。マクロを使用すると、コードの繰り返しを避け、動的な式をコンパイル時に生成できます。Rustにおけるマクロは、関数とは異なり、コードのパターンを記述し、それを使用して新しいコードを展開します。例えば、`println!`、`vec!`、`format!`はよく使われる標準マクロです。`println!`マクロは、フォーマットされた文字列を標準出力に出力します。`vec!`マクロは、特定の要素からベクタを作成します。これらのマクロは、コードをより簡潔にし、開発者の作業を容易にするために広く使用されています。マクロは非常に強力ですが、適切に使用する必要があります。それらはコンパイル時に展開されるため、実行時ではなく、コンパイル時にエラーチェックが行われます。

### マクロのメリット
- コンパイル時の柔軟性: マクロはコンパイル時にコードを生成します。これにより、マクロ内で使用されるコードは、マクロが呼び出される際にその場で生成され、コンパイルされるため、非常に柔軟なコード生成が可能になります。関数では、コードの構造がコンパイル時に固定されているため、このような柔軟性はありません。
- ドライ（DRY: Don't Repeat Yourself）原則の推進: マクロを使用すると、繰り返しの多いコードを簡潔に記述できます。たとえば、構造体の定義から自動的に特定のトレイトを実装するコードを生成するマクロなどがこれに該当します。これにより、コードベースをDRYに保ちやすくなります。
- 強力な抽象化: マクロは、型チェックの前に展開されるため、任意のトークン列を受け取り、有効なRustコードに変換できます。これにより、関数よりも高度な抽象化が可能になります。
- 構文拡張: マクロを使用すると、新しい構文やDSL（ドメイン特化言語）を作成できます。これにより、特定のタスクに特化した、より読みやすく、より書きやすいコードを提供できます。
