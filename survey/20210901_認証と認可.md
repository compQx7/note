# 認証と認可
## 認証（Authentication）
* 認証は相手が本人かどうかパスワードなどで確認する行為。
* 通信の相手が誰（何）であるかを確認すること

## 認可（Authorization）
* 認可は相手がアクセスするコンテンツに対して、アクセスの可否を制御すること。
* 特定の条件に対して、リソースアクセスの権限を与えること

# JWS
* ヘッダ、ペイロード、シグネチャで構成される。
* ヘッダは、ペイロードの種類や署名アルゴリズムを表明する。
* ペイロードではクレームセットを埋める。
* シグネチャには、ヘッダとペイロードを暗号鍵で署名した結果が入る。
* JWTはJWSによりエンコードされたペイロード（クレームセット）
* JWT自体は認証や暗号化に関してなにも規定していない。単にスペースに制約のあるHTTPヘッダーにJSONを載せるために、URLセーフでデータを小さくするJSONのデータフォーマット(表現形式)を決めているだけ。
* データは単にBase64URLエンコードしているだけなので、JWT単体で重要なデータを扱うのは問題がある。
* ペイロードの中身はデコードすれば見れてしまうし、改竄して送ることもできることは覚えておく。
* JWEはJWTを暗号化し中身自体を見られなくする仕組み。

## 生成フロー
1. ペイロードをBASE64URLエンコードする
2. ヘッダーをBASE64URLエンコードする
3. BASE64URL エンコードした1と2の結果を.(ドット)で繋ぐ
4. 3の結果を暗号鍵とalgに指定された方式で署名(暗号化)し、その結果をさらにBASE64URLエンコードする
5. 3(ヘッダー+ペイロード)と4(シグニチャ)の結果を.(ドット)で繋ぐ

# OAuth2.0
* ターゲットとなるシステムの特定のサービスに対して、別のシステムがアクセスすることを認可する仕組み。また、ユーザーがアプリケーションに対して、ユーザーが保持するコンテンツ（別システム）へのアクセスを認可する仕組み。
* 本来は認可(アクセス制限)のためのプロトコル
* ユーザーは認可サーバー（以降A）に対して、クライアントアプリ（以降C）のアクセストークン要求を許可する（認証情報を受け取る）。CはAに対して認証情報を送り、アクセストークンを取得。Cはリソースサーバー（以降R）に対してアクセストークンを送り（Rはアクセストークンの有効性確認を行う）、サービスを利用する。

# OpenID Connect
* OAuth2.0をユーザ認証として使えるように拡張したもの。認証時の情報を記載したIDトークンの概念が増えた。またユーザ情報を取得するためのエンドポイント（データを送受信するためのURL）を定めた。
* アプリAはアプリBにアクセストークンを発行してもらう際にIDトークンも発行してもらう。IDトークンにより、ユーザーを特定するIDや認証した日時の情報を知ることができる。
* アクセストークンを発行するサーバー（アプリB）をAuthorizationServer（OpeIDProvider）。発行してもらうアプリケーション（アプリA）をClient（RelyingParty）。アクセストークンでアクセスされるサーバー（アプリB）をResourceServerという。
* [リフレッシュトークン] アクセストークンを再発行する際に必要なトークン。
* [clientのタイプにより異なるアクセストークンのやり取り] SPA（SinglePageApplication）はブラウザ上で動くJavascriptで画面を書き換える形のWebアプリケーション。これはユーザ側とサーバー側のネットワークを跨ってアクセストークンがやり取りされるが、サーバー側に中継役のClientを用意することでサーバー側でやり取りさせることもできる。。それに対してMPAはサーバー側ネットワークで行われる。Webアプリではなくネイティブアプリ（OS上で動くアプリ）の場合、ユーザー側とサーバー側でアクセストークンは跨る形になる。

## エンドポイント
* [エンドポイントとは] リクエストを受け付けるURL
* [認可エンドポイント] 認証・認可を開始するためのエンドポイント。ユーザー端末から認可エンドポイントにリクエストすると、AuthorizationServerが認証・認可の画面を表示する。
* [トークンエンドポイント] トークンを取得するためのエンドポイント。AuthorizationServerがエンドポイントを提供し、clientがリクエストする。
* [リダイレクションエンドポイント] 認可エンドポイントで認証・認可した結果をclientが受け取るためのエンドポイント。clientが提供し、ユーザー端末からアクセスする。認可エンドポイントのレスポンスからリダイレクトしてアクセスするためユーザーは意識しない。

## 利用場面
* [SNSサイトのデータを利用したい] アプリA（client）でFacebook（Authorization server、Resource server）の友達一覧を利用したい。ユーザはFacebookに許可を出し、アプリAを利用する。
* [SNSサイトに認証を任せたい] アプリA（Client）で新規アカウントを作成せず、Facebook（Authorization server）のアカウントでログイン。Facebookからアクセストークンやユーザー情報を取得してアプリを利用する。
* [社内のシングルサインオンのプラットフォームにしたい] 社内の複数のアプリケーション（Client）でアイパスを社内の認証基盤（Authorization server）で一元管理したり、認証機能を統一したい。AuthorizationServerの自作はコストがかかるため、既存製品を使うことも多い。
* [バックエンドのサービス間で安全にAPIを呼び出したい] Webサービス(ResourceServer)をclientが呼び出すときにアクセストークンを渡し、呼び出されたWebサービスがアクセストークンの有効性を確認する。事前準備として、ユーザー情報を利用するのであれば、利用者がAuthorizationServerに認証を行いアクセストークンを取得する。逆にユーザー情報を使わないのであればclientがAuthorizationServerに認証してアクセストークンを発行するという選択肢もある。


# basic認証
* 手軽にできる分、セキュリティ強度は高くない
* .htaccessファイルを置いたフォルダは、アクセスするのにアイパスが必要になる。


# SSO(シングルサインオン)
* 基本的なシステム構成として、クッキーを利用したエージェント型とリバースプロキシを利用したリバースプロキシ型がある。
* [エージェント型] 登場人物はクライアントと認証サーバーとアプリケーションサーバー。クライアントが認証サーバーに認証リクエストし、セッション情報を受け取りクッキーとしてクライアントに保存する。クライアントからのリクエストを受けたアプリケーションサーバーは、クライアントのクッキーに保存されたセッション情報を読み取り、認証サーバーへクライアントの認証状態を確認する。セキュリティ上、クッキーに保存された情報にアクセスできるのは、そのクッキーを生成した認証サーバーと同一ドメインに属するサーバーに限られる。そのためアプリケーションサーバーは認証サーバーと同一ドメインに配置する必要がある。
* [リバースプロキシ型] 登場人物はクライアント、 リバースプロキシ、アプリケーションサーバー、認証サーバー。クライアントとアプリケーションサーバー、認証サーバーの間に入ったリバースプロキシが認証サーバーにアクセスし、クライアントのログイン状態に応じてアプリケーションサーバーへのアクセスの可否を管理する。アプリケーションサーバーはリバースプロキシ、認証サーバーと同一ドメインにも異なるドメインにも配置できる。利用者認証においてパスワードの代わりにデジタル証明書も利用可。
