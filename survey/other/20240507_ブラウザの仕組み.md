# ブラウザの仕組み

[参考](https://developer.chrome.com/blog/inside-browser-part1?hl=ja)
[MDN](https://developer.mozilla.org/ja/docs/Web/HTTP/Overview)
[MDN_ブラウザ動作の仕組み](https://developer.mozilla.org/ja/docs/Web/Performance/How_browsers_work#parsing)
[web.dev](https://web.dev/articles/howbrowserswork)

## プロセスとスレッド

- パソコンまたはスマートフォンでアプリを起動すると、そのアプリケーションで処理を行うのは CPU と GPU です。通常、アプリケーションはオペレーティング システムのメカニズムを使用して CPU と GPU で実行されます。
- ブラウザ アーキテクチャの説明に入る前に把握しておくべきもう一つの概念は、プロセスとスレッドです。プロセスは、アプリケーションの実行プログラムとして記述できます。スレッドはプロセス内に存在し、そのプロセスのプログラムの一部を実行します。
- アプリケーションを起動すると、プロセスが作成されます。プログラムは、動作を支援するためにスレッドを作成する場合がありますが、これは任意です。オペレーティング システムは、プロセスが処理するメモリの「スラブ」をプライベート メモリ空間に保持します。アプリを閉じると、プロセスも終了し、オペレーティング システムによってメモリが解放されます。
- あるプロセスは、別のプロセスを開始してさまざまなタスクを実行するよう、オペレーティング システムに要求できます。その場合、メモリのさまざまな部分が新しいプロセスに割り当てられます。2 つのプロセスで通信が必要な場合は、Inter Process Communication（IPC）を使用して通信できます。多くのアプリはこのように動作するように設計されています。そのため、ワーカー プロセスが応答しなくなった場合、アプリケーションの別の部分を実行している他のプロセスを停止することなく、ワーカー プロセスを再起動できます。
- ウェブブラウザはプロセスとスレッドを使用してどのように構築されるのでしょうか。1 つのプロセスに複数の異なるスレッドがある場合や、複数のスレッドが IPC を介して通信する多数の異なるプロセスである場合があります。これらの異なるアーキテクチャは実装の詳細であるということです。ウェブブラウザの構築方法に関する標準的な仕様はありません。ブラウザによって方法が完全に異なる場合があります。
- 1 つのプロセスですべてのタブが動作している場合、1 つのタブが応答しなくなると、すべてのタブが応答しなくなります。
- ブラウザの処理を複数のプロセスに分割することのもう一つの利点は、セキュリティとサンドボックス化です。オペレーティング システムにはプロセスの権限を制限する手段があるため、ブラウザは特定のプロセスを特定の機能からサンドボックス化できます。たとえば Chrome ブラウザは、レンダラ プロセスなど、任意のユーザー入力を処理するプロセスに対して、任意のファイル アクセスを制限します。
- ブラウザ プロセスにも同じ手法が適用されます。Chrome では現在、ブラウザ プログラムの各部分をサービスとして実行し、複数のプロセスに分割したり、1 つに集約したりできるようにアーキテクチャの変更を進めています。
- プロセスには独自のプライベート メモリ空間があるため、多くの場合、共通のインフラストラクチャのコピー（Chrome の JavaScript エンジンである V8 など）が含まれます。つまり同じプロセス内のスレッドの場合のようには共有できないため、メモリ使用量が増えます。 Chrome では、メモリを節約するために、スピンアップできるプロセスの数に上限を設けています。 上限はデバイスのメモリと CPU の処理能力によって異なりますが、上限に達すると、Chrome は 1 つのプロセスで同じサイトの複数のタブを実行するようになります。

## ナビゲーションの流れ

- Chrome では、アドレスバーは検索入力フィールドでもあるため、検索エンジンとリクエストしたサイトのどちらにリダイレクトするかを、UI スレッドが解析して決定する必要があります。
- UI スレッドがサイト コンテンツを取得するためのネットワーク呼び出しを開始します。読み込みスピナーがタブの隅に表示され、ネットワーク スレッドが DNS ルックアップやリクエストの TLS 接続の確立などの適切なプロトコルを通過します。
- レスポンスの本文（ペイロード）の受信が開始されると、ネットワーク スレッドは必要に応じてストリームの最初の数バイトを確認します。レスポンスの Content-Type ヘッダーにはデータの種類が示されていますが、これは欠落しているか間違っている可能性があるため、MIME タイプ スニッフィングを行います。
- すべてのチェックが完了し、リクエストされたサイトにブラウザからアクセスできることがネットワーク スレッドによって確認されると、ネットワーク スレッドは UI スレッドにデータの準備ができたことを伝えます。UI スレッドは、ウェブページのレンダリングを続けるレンダラ プロセスを見つけます。
- データとレンダラ プロセスの準備ができたら、IPC がブラウザ プロセスからレンダラ プロセスに送信され、ナビゲーションが commit されます。また、レンダラ プロセスが HTML データを受信し続けることができるように、データ ストリームも渡します。ブラウザ プロセスが、レンダラ プロセスで commit が発生したことを確認すると、ナビゲーションが完了し、ドキュメントの読み込みフェーズが開始します。
- ナビゲーションが commit されると、レンダラ プロセスがリソースの読み込みを進め、ページをレンダリングします。この段階で何が行われるかについては、次回の投稿で詳しく説明します。レンダラ プロセスがレンダリングを「終了」すると、IPC をブラウザ プロセスに返します（ページ内のすべてのフレームですべての onload イベントが発生し、実行を完了した後）。この時点で、UI スレッドはタブの読み込みスピナーを停止します。「完了」と呼ぶのは、この時点の後もクライアント側の JavaScript で追加のリソースの読み込みや新しいビューのレンダリングを行えるためです。

## レンダラプロセスの内部動作（Critical rendering path）

解析

- レンダラ プロセスの主な役割は、HTML、CSS、JavaScript を、ユーザーが操作できるウェブページにすることです。
- レンダラ プロセスがナビゲーションの commit メッセージを受信し、HTML データの受信を開始すると、メインスレッドはテキスト文字列（HTML）の解析を開始し、DOM に変換する。
- ウェブサイトでは通常、画像、CSS、JavaScript などの外部リソースを使用します。これらのファイルは、ネットワークまたはキャッシュから読み込む必要があります。メインスレッドは、DOM の解析中に検出されると、それらを 1 つずつリクエストすることもできますが、速度を上げるために「プリロード スキャナ」を同時に実行します。HTML ドキュメントに `<img>` や `<link>` のようなものがある場合、プリロード スキャナは HTML パーサーによって生成されたトークンをのぞいて、ブラウザ プロセスのネットワーク スレッドにリクエストを送信します。
- HTML パーサーは、`<script>` タグを検出すると HTML ドキュメントの解析を一時停止し、JavaScript コードを読み込んで解析し、実行します。HTML パーサーは、JavaScript の実行を待ってから、HTML ドキュメントの解析を再開する必要があります。JavaScript で document.write() が使用されていない場合は、async 属性または defer 属性を `<script>` タグに追加できます。その後、ブラウザは JavaScript コードを非同期で読み込んで実行するため、解析はブロックされません。必要に応じて、JavaScript モジュールを使用することもできます。`<link rel="preload">` は、現在のナビゲーションにこのリソースが必要であり、できるだけ早くダウンロードしたいことをブラウザに伝えるための手段です。

スタイルの計算

- メインスレッドは CSS を解析し、各 DOM ノードについて算出したスタイルを決定します。DevTools の computed セクションで確認できます。
- CSS を指定しない場合でも、各 DOM ノードのスタイルが計算されます。<h1> タグは <h2> タグよりも大きく表示され、マージンは各要素に定義されます。これは、ブラウザにデフォルトのスタイルシートがあるためです。

レイアウト

- レイアウトは、要素のジオメトリを見つけるプロセスです。
- メインスレッドは、DOM と計算されたスタイルを調べて、x y 座標や境界ボックスのサイズなどの情報を含むレイアウト ツリーを作成します。レイアウト ツリーの構造は DOM ツリーに似ていますが、含まれるのはページに表示される情報に関連する情報のみです。display: none が適用されている場合、その要素はレイアウト ツリーの一部ではありません（ただし、visibility: hidden を持つ要素はレイアウト ツリー内にあります）。同様に、p::before{content:"Hi!"} のようなコンテンツを含む疑似クラスが適用されると、それが DOM 内になくてもレイアウト ツリーに含まれます。

Paint

- DOM、スタイル、レイアウトだけでは、ページをレンダリングできません。絵画を再現するとします要素のサイズ、形状、位置は把握していますが、描画する順序を決める必要があります。たとえば、特定の要素に z-index が設定されている場合、HTML で記述された要素順にペイントすると、レンダリングが正しく行われません。

ここまでのフロー

- レンダリング パイプラインで把握すべき最も重要なことは、各ステップで、前のオペレーションの結果を使用して新しいデータが作成されることです。たとえば、レイアウト ツリーに何かが変更された場合、ドキュメントの影響を受ける部分に対してペイント順序を再生成する必要があります。
- 要素をアニメーション化する場合、ブラウザはすべてのフレーム間でこれらの処理を実行する必要があります。ほとんどのディスプレイでは、画面が 1 秒間に 60 回（60 fps）更新されます。フレームごとに画面上を移動すると、アニメーションが滑らかに表示されます。ただし、アニメーションの中間にフレームがない場合、ページは「ジャンク」しているように見えます。
- レンダリング オペレーションが画面の更新に対応できている場合でも、こうした計算はメインスレッドで実行されるため、アプリケーションが JavaScript を実行しているときにブロックされる可能性があります。

ラスタライズ

- ブラウザはドキュメントの構造、各要素のスタイル、ページのジオメトリ、ペイント順序を認識し、ページをどのように描画するのでしょうか。この情報を画面上のピクセルに変換することを ラスタライズと呼びます。
- これを扱う単純な方法は、ビューポート内でパーツをラスターすることです。ユーザーがページをスクロールしたら、ラスター化されたフレームを移動し、さらにラスター化して欠落している部分を埋めます。これは、Chrome が最初にリリースされたときのラスタライズの処理方法です。ただし、最新のブラウザでは、合成と呼ばれるより高度なプロセスが実行されます。
- コンポジットとは、ページの一部をレイヤに分割して個別にラスタライズし、コンポジタ スレッドという別のスレッドに 1 つのページとして合成する手法です。スクロールが発生した場合、レイヤはすでにラスタライズされているため、必要な作業は新しいフレームを合成することだけです。レイヤを移動したり、新しいフレームを合成したりすることで、アニメーションも同様に作成できます。ウェブサイトがどのようにレイヤに分割されているかは、DevTools の[レイヤ] パネルで確認できます。
- どの要素をどのレイヤに配置する必要があるかを特定するために、メインスレッドはレイアウト ツリーを順に確認してレイヤツリーを作成します（この部分は DevTools のパフォーマンス パネルで「Update Layer Tree」と呼ばれます）。
- レイヤツリーが作成されてペイントの順序が決定されると、メインスレッドはその情報をコンポジタ スレッドに commit します。その後、コンポジタ スレッドが各レイヤをラスタライズします。レイヤはページ全体の長さほど大きくなる場合があるため、コンポジタ スレッドがレイヤをタイルに分割し、各タイルをラスター スレッドに送信します。ラスター スレッドは各タイルをラスタライズして GPU メモリに格納します。
- ビューポート内（または付近）のものを最初にラスターできるように、コンポジタ スレッドが異なるラスター スレッドに優先順位を付けることができます。レイヤには、ズームイン操作などを処理するための、さまざまな解像度の複数のタイルもあります。
- 合成のメリットは、メインスレッドを介さずに実行されることです。コンポジタ スレッドは、スタイルの計算や JavaScript の実行を待機する必要はありません。そのため、スムーズなパフォーマンスを実現するために、アニメーションのみの合成が最適とみなされます。レイアウトまたはペイントを再度計算する必要がある場合は、メインスレッドが関与する必要があります。
