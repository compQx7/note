# command

## grep

grep [option] `<pattern>` `<target>`

| option | 内容 | 備考 |
| --- | --- | --- |
| -v `<pattern>` | 除外 |
| -i `<pattern>` | 大文字小文字区別なし |
| -r | 再帰 |
| --include='*.{拡張子}' | 拡張子を指定 |
| -o `<pattern>` | 特定部分のみ抽出 | 例: `-o "word.*"`でword以降部分を抽出 |

## sort

sort [option] [-k `<field（数字で）>`] `<target>`

| option | 内容 |
| --- | --- |
| -r | 降順 |
| -n | 数値順 |
| -f | 大文字小文字区別なし |

## wc

wc [option] `<target>`

オプション無しで、行数、単語数、バイト数が表示される。

| option | 内容 |
| --- | --- |
| -l | 行数 |
| -w | 単語数 |
| -c | バイト数 |

## head, tail

head [-n `<number>`] `<target>`
tail [-n `<number>`] `<target>`

| option | 内容 |
| --- | --- |
| -f | 今も書き込まれ続けているログファイルなどをリアルタイム監視 |

## find

[qiita](https://qiita.com/ko1nksm/items/7fec71f78a394a80ed2b)

- 指定したパスから検索する

```sh
find [option] searchPath... [評価式]
```

- -nameなどの引数はクオートが必要。シェルではなくコマンドが処理するため。

```sh
# これだとシェルで展開している
find *.txt
# find で検索する場合
find . -name '*.txt'
```

### 評価式

- 評価意識は要素式（-name）と演算子（-a）の組み合わせ
- 評価式は SQL でいう WHERE 句。

```sh
# 拡張子が txt かつ ファイルを抽出
find . -name '*.txt' -a -type f
```

- 演算子の優先順位は`()`, `!`, `-a`, `-o`

- `-name`, `-path`, `-type`
- `-prune` はそれがディレクトリの場合にディレクトリ以下の探索を行わない。

### アクション

- `-depth` はディレクトリそのものよりも中身を先に処理する。（常に真を返す）
- `-exec <コマンド> {} [\;|';']` はコマンド実行。（終了ステータスが0なら真を返す）
  - `{}` に対象ファイルを入れて実行される。
  - `\;` の代わりに `+` を使った場合は、常に真を返す。`+` は並列のため高速。
- 省略したら `-print`。

### 例

```sh
# node_modules を削除する
$ find . -name 'node_modules' -type d  -prune | awk '{print "rm -rf", $0}' | sh
```

## sed

sed 's/old/new/' `<target>`

| option | 内容 | 備考 |
| --- | --- | --- |
| -i | ファイル編集 | `-i.bak` とするとバックアップを作成しつつ編集 |
| -e | 複数パターン指定 | e.g. `sed -e 's/new1/old1/' -e 's/new2/old2/' filename` |
| 's/old/new/g' | 行全体で複数回置換 |  |
| '/pattern/d' | 行削除 |  |
| '2,4s/old/new/' | 行範囲指定 |  |
| 's/`<regex>`/new/' | 正規表現可 | e.g. 空白指定: `^[ \t]*` |

sed -f `<*.sed>` filename
コマンドをファイルから読み込んで実行
