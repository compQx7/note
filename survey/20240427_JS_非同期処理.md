# JS 非同期処理

## 非同期処理

[イベントループとプロミスチェーンで学ぶJavaScriptの非同期処理](https://zenn.dev/estra/books/js-async-promise-chain-event-loop)

- 非同期処理の本質的な仕組みは「イベントループにおけるタスクとマイクロタスクの処理」

- API は実行環境によって提供されている。各ブラウザから提供されているもの、JavaScript 実行環境（node, demo）から提供されているもの、Third Party から提供されるものとある。
  - fetch, setTimeout といった非同期処理が実施されるメソッドはその処理を外部のAPIが担う。
  - DOM 操作はブラウザが提供している。Node.js の DOM 操作 API の役割を果たすのが例えば js-dom である。Node.js 上で DOM に関わるテストができるライブラリである「testing-library」も js-dom を必要とする。
- シングルスレッドで実行されるとは、単一のコールスタックで実行されるということ。
- ブラウザ環境の文脈でいえば JavaScript は（Renderer Processの）メインスレッドで実行される。長時間メインスレッドを占有すると他に何もできなくなる（ブロッキング）。
- 時間を測るという作業やインターネットを介したデータ取得などの行為自体は API を介して 環境が代わりにバックグラウンドで並列的に行ってくれる。
- API の呼び出しは 環境へ作業を委任 (delegate) するという行為。
- JavaScript はシングルスレッドで実行されるが、環境はマルチプロセスアーキテクチャ。
- 環境が提供する機能である API を介して時間のかかる処理を環境に委任し、それが完了したら JavaScript のメインスレッドにその処理結果となるデータと共に通知させてその作業に関連する何か別の作業をコールバックなどの形式で行う」というのが「非同期処理」の全体的な仕組み
- API を介した作業を環境が代わりに並列的に行っている間もメインスレッドで別の作業を続けられるようにするのが非同期処理の大きな目的
- async 関数は内部に await 式がある時に限って「非同期」となる。Promise は後続の then() メソッドがある場合、つまり Promise chain となっている場合に限って「非同期」となる。「非同期」という性質を持った「処理」がそれ単体で存在する訳ではありません。他のコードとの関係性があって始めて成り立つ事象を指し示す概念。
- ユーザーインタラクションやイベント処理、setTimeout() などのタイマー処理によってスケジューリングすることで意図的に非同期にすることを除けば、効率の良い非同期 API を使用したいがために結果的に付随する処理がタイミングのズレる非同期処理になってしまう。

- イベントループはタスクキューとマイクロタスクキュー内にあるタスク/マイクロタスクを処理するためのループアルゴリズム。イベントループは次に実行するタスクあるいはマイクロタスクを選択して、コールスタック(Call Stack)へと配置する。
- マイクロタスクキューはタスクキューよりも優先的に処理される。単一タスクが終わったら、すべてのマイクロタスクを処理する。つまり、「コールスタックが空になったらマイクロタスクを処理する」。

## イベントループ: microtask と macrotask

[javascript.info](https://ja.javascript.info/event-loop)

イベントループのより詳細なアルゴリズム(仕様と比べると簡素化されていますが):

1. macrotask キューにある最も古いタスク(e.g “スクリプト”)を取り出して実行します。
2. すべての microtask を実行します。
  -  microtask キューが空でない間
    -  最も古い microtask を取り出して実行します。
3. 変更がある場合はレンダリングします。
4. macrotask キューが空であれば、macrotask が現れるまで待ちます。
5. ステップ1 に戻ります。

- すべての macrotask の直後に、エンジンは他の macrotask やレンダリングなどを実行する前に microtask キューにあるすべてのタスクを実行します。
- すべての microtask は他のイベントハンドリングやレンダリング、または他の macrotask が行われる前に完了します。
- Microtasks は通常は promise によって作成され、.then/catch/finally ハンドラの実行は microtask になります。Microtask は同様に promise ハンドリングの別の形の await の中でも使用されています。
- Microtask キューで実行するために func をキューする queueMicrotask(func) という特別な関数もあります。

- 新しい macrotask をスケジュールするには:
  - 遅延ゼロの setTimeout(f) を使用します。
    - これは、ブラウザがユーザーイベントに反応したり、タスクの進捗状況を表示することができるよう、計算量の多いタスクを小さく分割するために使用されます。
    - また、イベントが完全に処理された(バブリングが完了した)後にアクションを行うようスケジュールするために、イベントハンドラ内でも使われることがあります。
- 新しい microtask をスケジュールするには:
  - queueMicrotask(f) を使用します。
  - また、promise ハンドラは microtask キューで処理されます。

下記のコードの実行順

1. 通常の同期呼び出しである code が最初に表示ます。
2. promise が次に表示されます。なぜなら、.then は microtask キューを通じて、現在のコードの後に実行されるからです。
3. macrotask である timeout が最後に表示されます。

```js
setTimeout(() => alert("timeout"));

Promise.resolve()
  .then(() => alert("promise"));

alert("code");
```
